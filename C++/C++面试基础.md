# <center>C++面试基础</center>
1. <a href="#C++引用">C++引用</a>
2. <a href="#C++左值与右值">C++左值与右值</a>
3. <a href="#C++指针">C++指针</a>
4. <a href="#C++编译过程">C++编译过程</a>
	- <a href="#C++静态链接与动态链接">C++静态链接与动态链接</a>
5. <a href="#C++内存分配">C++内存分配</a>
6. <a href="#C++类型转换">C++类型转换</a>
7. <a href="#C++static">C++ static</a>
	- <a href="#C++中static的作用">C++中static的作用</a>
	- <a href="#static存放的数据位置">static存放的数据位置</a>
	- <a href="#全局变量和全局静态变量区别">全局变量和全局静态变量区别</a>
	- <a href="#局部变量和静态局部变量区别">局部变量和静态局部变量区别</a>
	- <a href="#static用法">static用法</a>
	- <a href="#static成员函数函数相关">static成员函数函数相关</a>
10. <a href="#C++const">C++const</a>
	- <a href="#const修饰函数参数">const修饰函数参数</a>
	- <a href="#const成员函数">const成员函数</a>
	- <a href="#const修饰返回值">const修饰返回值</a>
11. <a href="#C++多态">C++ 多态</a>
	- <a href="#C++静态多态">C++静态多态</a>
	- <a href="#C++动态多态">C++动态多态</a>
	- <a href="#静态多态动态多态优缺点">静态多态动态多态优缺点</a>
	- <a href="#C++子类继承和调用父类的构造函数方法">C++子类继承和调用父类的构造函数方法</a>
	- <a href="#虚函数原理">虚函数原理</a>
	- <a href="#虚函数工作原理">虚函数工作原理</a>
12. <a href="#C++STL">C++STL</a>
	- <a href="#STL容器与迭代器">STL容器与迭代器</a>
	- <a href="#STL序列式容器">STL序列式容器</a>
	- <a href="#STLlist">STL list</a>
	- <a href="#STL关联式容器">STL关联式容器</a>
	- <a href="#C++STL无序容器">C++STL无序容器</a>
	- <a href="#STL线程安全">STL线程安全</a>
13. <a href="#C++构造函数/析构函数">C++构造函数/析构函数</a>
	- <a href="#构造函数与析构函数">构造函数与析构函数</a>
	- <a href="#构造函数和析构函数能否为虚函数">构造函数和析构函数能否为虚函数</a>
	- <a href="#构造函数和析构函数能否抛出异常">构造函数和析构函数能否抛出异常</a>
	- <a href="#构造函数/拷贝构造函数和赋值函数的区别和实现">构造函数/拷贝构造函数和赋值函数的区别和实现</a>
	- <a href="#C++函数初始化方式">C++函数初始化方式</a>
	- <a href="#C++初始化列表">C++初始化列表</a>
14. <a href="#C++友元函数">C++友元函数</a>
15. <a href="#C++11">C++11</a>
	- <a href="#auto类型推导">auto类型推导</a>
	- <a href="#decltype类型推导">decltype类型推导</a>
	- <a href="#lambda匿名函数">lambda匿名函数</a>
	- <a href="#右值引用">右值引用</a>
	- <a href="#移动构造函数">移动构造函数</a>
	- <a href="#nullptr">nullptr</a>
16. <a href="#智能指针">C++11 智能指针</a>
	- <a href="#auto_ptr">auto_ptr</a>
	- <a href="#unique_ptr">unique_ptr</a>
	- <a href="#shared_ptr">shared_ptr</a>
	- <a href="#weak_ptr">weak_ptr</a>
	- <a href="#shared_ptr简单实现">shared_ptr简单实现</a>
	- <a href="#shared_ptr循环引用问题">shared_ptr循环引用问题</a>
17. <a href="#C++基础补充">C++基础补充</a>
	- <a href="#C++与C的区别">C++与C的区别</a>
	- <a href="#C++与java的区别">C++与java的区别</a>
	- <a href="#C++与Python的区别">C++与Python的区别</a>
	- <a href="#面向对象">面向对象的三大特征</a>
	- <a href="#C++大括号的作用">C++大括号的作用</a>
	- <a href="#new/delete和malloc/free区别">new/delete和malloc/free区别</a>
	- <a href="#C++空类有什么默认函数">C++空类有什么默认函数</a>
	- <a href="#C++内存泄露">C++内存泄露</a>
	- <a href="#C++野指针">C++野指针</a>
	- <a href="#C++内存对齐">C++内存对齐</a>
	- <a href="#C++volatile关键字">C++volatile关键字</a>
	- <a href="#C++struct">C++struct</a>
	- <a href="#C++string">C++string</a>
	- <a href="#C++内联函数">C++内联函数</a>
	- <a href="#C++RTTI">C++RTTI</a>
	- <a href="#C++void*">C++void*</a>
	- <a href="#memecpy和strcpy">memecpy和strcpy</a>
	- <a href="#C++设计模式">C++设计模式</a>

## <p id="C++引用">C++引用</p>
**引用是什么？**

引用是一种特殊类型的指针，是一种不允许修改的指针。

**引用与指针的区别**

- 指针有自己的空间，指向对象的地址，引用没有自己的空间，实际上是对象的别名。
- 指针的sizeof大小为4(32位，4个字节)，而引用是被引用对象大小。
- 引用在定义的时候必须初始化，指针可以初始化为NULL(nullptr)。
- 指针可以改变地址，引用必须从一而终。
- 指针可以有多级指针，引用只有一级。

**使用指针可能出现的问题**

- 空指针。
- 野指针。
- 不知不觉改变了指针的值，却继续使用。

对此，如果使用引用，则可以：

- 不存在空引用(定义时就要初始化)。
- 定义时就要初始化。
- 一个引用永远指向它初始化的那个对象。

**有了指针为什么还需要引用：** 首先是为了支持函数运算符重载，其次解决上述指针可能存在的问题。

**有了引用为什么还需要指针：** 为了兼容C语言，而且在使用上相对于引用更为灵活。

**引用的使用方式**

引用的使用可以认为是指定变量的别名，使用时可以认为是变量本身。
<pre>
int x = 1, x2 = 3;
int& rx = x;
rx = 2;
cout<< x << endl; //2
cout<< rx << endl; //2
rx = x2;
cout<< x << endl; //3
cout<< rx << endl; //3
</pre>
**需要注意的是，引用在定义的时候需要加&，而在使用的时候不需要，使用时添加&是表示取其地址。关于这一点，个人理解是，与下文指针一样，可以理解为int& rx (int\* rx) 中int& (int\*) 可以连起来看做类型，这样的话变量名其实是rx，类型为int&（int\*），这样就会清楚为什么使用的时候不用加‘&’或者‘\*’。**

## <p id="C++左值与右值">C++左值与右值</p>
左值是“lvalue”， 是“locator value”的缩写，可以意味是**存储在内存中，有明确地址（可寻址）的数据。**而右值是“rvalue”是“read value”，指的是那些**可以提供数据值的数据。**

判断一个值（表达式）为左值还是右值的方式：

- 可位于赋值号（=）左侧的表达式就是左值，只能位于赋值号右侧的表达式就是右值。
- 有名称，可以获取到存储地址的表达式为左值，反之为右值。

<pre>
int a = 5;
5 = a;//错误，5不能为左值。

int b = 10;//b是左值。
a = b;//a, b都是左值，只不过此时将b当做右值使用。
</pre> 

对于++x以及x++，比较复杂，++x为左值，而x++为右值。究其原因&(++x)是有效的，而&(x++)是无效的，对于前者操作系统所做的事情是取出x的地址并且进行修改，返回的是x自身，而对于x++，则会新建一个临时对象，然后执行操作后返回临时对象，所以不能当做左值。

在C++11中引入了<a href="#右值引用">右值引用</a>的概念, 后面会详细介绍。

## <p id="C++指针">C++指针</p>
C++指针在32位机中大小为4B，在64位机中大小为8B。

指针的数组T* t[]。

数组的指针T(*t) []。

例如：
<pre>
int* a[4];
int (*b)[4]; //注意[]优先级比较高
</pre>
为了更好的展示数组的指针与指针数组的区别，可以使用以下代码：
<pre>
//array of pointers and pointer to an array
int c[4] = {1,2,3,4};
int* a[4]; //array of pointers, 指针数组
int(* b)[4]; //pointer to an array 数组的指针
b = &c; //指针保存的是数组的地址，这里数组的个数需要匹配。
//将数组c中的元素赋值给a
for(int i=0; i<4; i++){
	a[i] = &(c[i]);
}
//输出 
cout<< *(a[0]) << endl; 
cout<< (*b)[3] << endl; 
for(int i=0; i<4; i++) {
	cout<< "c["<< i<< "]: "<< c[i]<< " address: "<< &(c[i])<< endl;
}
for(int i=0; i<4; i++) {
	cout<< "a["<< i<< "]: "<< a[i]<< " address: "<< &(a[i])<< endl;
}
cout<< "b: "<< b<< " address: "<< &b<< endl;
</pre>
输出如下：
<pre>
1
4
c[0]: 1 address: 0x6ffdf0
c[1]: 2 address: 0x6ffdf4
c[2]: 3 address: 0x6ffdf8
c[3]: 4 address: 0x6ffdfc
a[0]: 0x6ffdf0 address: 0x6ffdc0
a[1]: 0x6ffdf4 address: 0x6ffdc8
a[2]: 0x6ffdf8 address: 0x6ffdd0
a[3]: 0x6ffdfc address: 0x6ffdd8
b: 0x6ffdf0 address: 0x6ffde8
</pre>
从上面的输出可以看出，a是一个指针数组，数组中每一个元素为c对应元素的地址，而b是c的指针，指向c第一个元素的地址。

关于const指针，请参考<a href="#Const">C++ Const</a>中的内容。

**C++中的原始指针**

**指向指针的指针**

例如：
<pre>
int a =123;
int* b = &a;
int** c = &b;
cout<< "a: "<< a<< " &a: "<< &a<< endl;
cout<< "b: "<< b<< " &b: "<< &b<< " *b: "<< *b<< endl;
cout<< "c: "<< c<< " &c: "<< &c<< " *c: "<< *c<< " **c: "<< **c<< endl;
</pre>

输出：

<pre>
a: 123 &a: 0x6ffdfc
b: 0x6ffdfc &b: 0x6ffdf0 *b: 123
c: 0x6ffdf0 &c: 0x6ffde8 *c: 0x6ffdfc **c: 123
</pre>

则其关系如下图：

![avatar](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/1.png)

<table>
	<tr>
		<th>
			表达式
		</th>
		<th>
			表达式的值
		</th>
	</tr>
	<tr>
		<th>
			a
		</th>
		<th>
			123
		</th>
	</tr>
	<tr>
		<th>
			b
		</th>
		<th>
			&a
		</th>
	</tr>
	<tr>
		<th>
			*b
		</th>
		<th>
			a, 123
		</th>
	</tr>
	<tr>
		<th>
			c
		</th>
		<th>
			&b
		</th>
	</tr>
	<tr>
		<th>
			*c
		</th>
		<th>
			b, &a
		</th>
	</tr>
	<tr>
		<th>
			**c
		</th>
		<th>
			*b, a, 123
		</th>
	</tr>
</table>

\*号操作符具有从右往左的结合性，\*\*这个表达式相当于\*（\*c)，必须从里向外逐层求值。\*c得到的是c指向的位置，即b。\*\*c相当于\*b，得到变量a的值。

**未初始化和非法指针**

对于以下使用方式：

<pre>
int *a;
*a = 12;
</pre>

由于a没有进行初始化，运气好的话，定义到一个非法地址，程序会出错终止，运气不好的话，定位到一个可以访问的地址，并且无意间修改了其值，这样的错误难以被捕捉到，引发的错误可能与原先用于操作的代码完全不相关。

用于指针进行间接访问之前，一定要非常小心，**确保他已经初始化，并被恰当的赋值。**

**野指针**

野指针是指指向被释放的或者访问受限内存的指针。造成野指针的原因有：

1. 指针变量没有初始化。（可以初始化为NULL)
2. 指针被free/delete掉之后，没有设置为NULL，free和delete只是把指针所指向的内存释放掉，并没有把指针本身干掉，此时指针应该被设置为NULL。
3. 指针操作超越了变量的作用范围，比如返回指向栈内存的指针。

**原始指针的基本运算**

- &与*操作符

<pre>
char ch = 'a';
char* cp = &ch;
</pre>

根据上面的表达式，我们有以下一些操作，其中加粗圆圈表示输出，加粗方框表示数据写入位置（作为左值时数据写入位置）。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/2.jpg)

其中，&ch(&cp)作为右值时表示ch(cp)的地址，我们也知道&ch(&cp)并不能作为左值使用。


![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/3.png)

\*cp作为右值时表示ch的值(可以理解为cp = &ch -> \*cp=\*&ch -> \*cp = ch)，作为左值时，表示修改ch的值。

\*cp + 1作为右值时表示ch的值加一，在上图中为'a'+1='b'。作为左值时非法，因为常量不能作为左值。

\*(cp + 1)作为右值表示ch所在地址向后移动一位（因为此时ch是char，占用一个字节，所以向后移动一个字节，如果是int，移动4个字节）后所在地址上的值。作为左值表示修改ch所在地址后移动一位的位置处的值。

- ++操作符

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/4.png)

同样是对上面的代码，执行++cp以及cp++操作，注意，对于++cp操作，作为右值时表示将cp所指向的地址向后移动一位后的地址，**作为左值时表示为输入数据所保存的地址。上图显示++cp左值非法，其实是合法的，详情请看上面<a href="#C++左值与右值">C++左值与右值</a>。**

但是对于cp++，其右值表示返回cp所指向地址后，cp向后移动一位，左值非法（原因是cp++返回的是一个临时变量，无法获取地址）。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/5.png)

对于以上操作，\*(++cp)作为右值表示，cp所指地址向后一位移动后中所存储的数据，左值则为修改该地址空间的值。

对于\*(cp++)作为右值表示，返回cp所指向地址中的值之后，cp向后移动一位，作为左值表示修改完cp所指地址中的值之后，cp向后移动一位。


- ++++，----操作符

编译器程序分解符号的方法是：一个字符一个字符的读入，如果该字符可能组成一个符号，那么读入下一个字符，一直读到输入的字符不能再组成一个有意义的符号，这个处理过程称为 “贪心法”。

例如
<pre>
int a = 1;
int b = 2;
int c;
c = a+++b; //相当于a++ + b，返回3.
int d = a++++b; //相当于a++ ++b，返回error。

</pre>

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/6.png)

如上表达式，++\*++cp作为右值时表示，cp指向的空间向后移动一位之后取到的值再加一后的值，**作为左值时依旧合法，与上面类似，其修改的位置为cp指向的空间向后移动一位之后的地址中的值。**

## <p id="C++编译过程">C++编译过程</p>
对于C++源文件，从文本到可执行文件一般需要四个过程：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/7.png)

### 预编译
**预编译**：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）、进行分析和替换，生成预编译文件。
主要针对以下四种伪指令和特殊符号：

1. 宏定义指令，如#define Name TokenString， # under等。 对于前一个伪指令，预编译要做的是将程序中的所有Name用TokenString替换，但作为字符串常量的Name则不被替换，对于后者，取消某个宏的定义，使以后该串的出现不再被替换。
2. 条件编译指令，如# ifdef， #ifndef， #else等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤。
3. 头文件包含指令，如#include"FileName"或者#include<FileName>等。
在头文件中一般用伪指令#define定义了大量的宏，同时包含有各种外部符号的声明。采用头文件的目的主要是为了使某些定义可以供多个不同的C源程序使用，而不需要在此文件中将这些定义重复一遍。预编译程序将把头文件中的定义统统加入到它所生产的输出文件中，以供编译程序对之进行处理.
4. 特殊符号，例如LINE标识将被解释为当前行号，FILE则被解释为当前被编译的C源程序名称，预编译程序对于在源程序中出现的这些串将用合适的值进行替换。

预编译程序所完成的工作主要是对源程序的“替代”工作，生成一个没有宏定义，没有条件编译，没有特殊符号的输出文件，但是这个文件的含义同没有经过预处理的源文件是相同的，但是内容有所不同。

### 编译
**编译**：将经过预处理的预编译文件转换成特定的汇编代码，生成汇编文件。

经过预编译得到的输出文件中，只有常量，如数字，字符串，变量的定义，以及C语言的关键字，如main， if， else， for， while等。编译程序要做的是通过词法分析和语法分析，在确认所有指令符合语法规则之后，将其翻译为等价的中间代码或者汇编代码。在此过程中，也要进行优化处理，包括删除公共表达式，循环优化，复写传播等，以及针对机器硬件结构相关的优化，比如如何充分利用机器的各个硬件寄存器存放的有关变量的值，减少对内存访问次数等。

经过优化得到的汇编代码必须经过汇编程序的汇编转换成相应的机器指令，才能被机器执行。

### 汇编
**汇编阶段**：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件。

汇编过程实际上是把汇编语言代码翻译成目标机器指令的过程，对于被翻译系统处理的每一个c语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件所存放的也就是与源程序等效的目标的机器语言代码，通常由多段组成，一个目标文件中至少有两段：代码段，数据段。

**代码段**：包含程序的指令，该段一般是可读和可执行的，但一般却不可写。

**数据段**：主要存放程序中要用到的各种全局变量或者静态数据，一般可读可写可执行。

汇编程序生成的实际上是第一种类型的目标文件：可重定位文件，其中包含有适用于其他目标文件链接来创建一个可执行的或者共享的目标文件的代码和数据。

### 链接
**链接过程**：将多个目标文件以及所需要的库连接成最终的可执行目标文件。

由汇编程序生成的目标文件不能马上被执行，因为还有一些问题，例如某个源文件中的函数可能引用了另一个源文件中定义的某个符号，在程序中可能调用了某个库文件中的函数。

链接程序的主要工作就是将有关的目标文件彼此相连，也即将在一个文件中引用的符号通该符号在另外的文件中的定义连接起来，使得所有目标文件成为一个能够被操作系统装入执行的统一整体。

### <p id="C++静态链接与动态链接">C++静态链接与动态链接</p>
**静态链接(.a, .lib)：**
在这种链接方式下，函数的代码将从其所在的静态链接库中被拷贝到最终的可执行程序中，这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。静态链接库在程序编译时被链接到目标代码中，链接时将库完整地拷贝到可执行文件中。

**动态链接(.so, .dll)：**
在此种链接方式下，函数的代码将被放到称作是动态链接库或者共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字和其他少量的登记信息。在可执行文件被执行时，动态链接库的全部内容将被映射到运行时相对应进程的虚拟地址空间中。动态链接程序将根据可执行程序中记录的信息找到相对应的函数代码。动态链接在程序运行时由系统动态加载动态库到内存。
动态链接与静态链接区别：

1. 动态链接相比静态链接，其最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因此在内存中只需要保存一份此共享的代码。
2. 静态库更新，每个使用该静态库的程序都需要更新，不易于更新升级。动态库只需更新自身，易于升级更新。
3. 静态链接库不能包含其他动态链接库，动态链接库可以包含其他动态链接库。
4. 静态链接库代码装载速度快，执行速度略比动态链接库快。
5. 静态链接库只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需要考虑用户的计算机上.LIB文件是否存在以及版本问题，可避免DLL地狱等问题（DLL版本不兼容导致程序无法正常运行）。

**GCC的编译链接**

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/8.png)

GCC编译器在使用时，是将以上过程捆绑。使得用户一次命令就能把编译工作完成，方便了编译工作。

1. 预编译： 将.c文件转换为.i文件，使用的gcc命令是：gcc -E，对应于预处理命令cpp。
2. 编译：将.c/.h文件转化为.s文件，使用的gcc命令是：gcc -S，对应于编译命令 cc -S。
3. 汇编：将.s文件转换为.o文件，使用的gcc命令是：gcc -C，对应于汇编命令as。
4. 链接：将.o文件转化为可执行程序，使用gcc命令是：gcc，对应于链接命令是ld。

总结起来：预编译程序（.c) -->编译，优化程序(.s, .asm) --> 汇编(.obj, .o, .a, .ko) -->链接程序(.exe, .elf, .axf等）。 

## <p id="C++内存分配">C++内存分配</p>
C++编译的程序占用内存分为以下几个部分：

**栈区**：由编译器自动分配与释放，存放为运行时函数分配的局部变量，函数参数，返回数据，返回地址等，其操作类似于数据结构中的栈。

**堆区**：一般由程序员自动分配，如果程序员没有释放，程序结束时可能有OS进行回收。其分配方式类似于链表。

**全局区（静态区）**：存放全局变量，静态变量，常量。程序结束后由系统释放。全局区分为已初始化全局区（data）和未初始化全局区（bss）。

**常量区（文字常量区）**：存放常量字符串，程序结束后由系统释放。

**代码区**：存放函数体（类成员函数和全局区）的二进制代码。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/9.png)

**C语言参数的压栈顺序：**从右到左。对于不定参函数，要知道参数个数，要使用从右往左压栈方式，例如printf函数。printf(const char* format,...)，要知道参数的个数，通过format中的占位符%个数来确定，但是如果从左往右压栈，format函数先进栈，要知道参数个数要先找到format函数，要找到format函数要先知道参数个数。所以要从右到左压栈。

<pre>
int a = 0; //(Data)全局初始化区
int*p; //(Bss)全局未初始化区	
int main() {
	int b; //(Stack)栈区
	char s[] = "abc"; //(Stack)栈区
	int* p2; //(Stack)栈区
	char* p3 = "123456"; //123456\0在常量区，p3在栈区
	static int c = 0; //(Data)全局初始化区
	p1 = new int(10); //(Heap)堆区
	p2 = new int(20); //(Heap)堆区
	return 0; //(Text)代码区
}
</pre>

**C++几种变量的对比**

堆栈的比较：
<table>
	<tr>
		<th>
			-
		</th>
		<th>
			栈区（Stack）
		</th>	
		<th>
			堆区（heap）
		</th>
	</tr>
	<tr>
		<th>
			作用域
		</th>
		<th>
			函数体内，语句块{}作用域。
		</th>	
		<th>
			整个程序范围内，由new，malloc开始，delete，free结束。
		</th>
	</tr>
	<tr>
		<th>
			编译间大小确定
		</th>
		<th>
			变量大小范围确定。
		</th>	
		<th>
			变量大小范围不确定，需要运行期间确定。
		</th>
	</tr>
	<tr>
		<th>
			大小范围
		</th>
		<th>
			Windows系统默认栈大小是1M，linux常见默认的栈大小是8M或者10M，通过ulimit -s查看，不同linux发行版本的命令不同。
		</th>	
		<th>
			所有系统的堆空间上限是接近内存（虚拟内存）的总大小（一部分被OS占用）。
		</th>
	</tr>
	<tr>
		<th>
			内存分配方式
		</th>
		<th>
			地址由高到低分配
		</th>	
		<th>
			地址由低到高分配
		</th>
	</tr>
	<tr>
		<th>
			内容是否可变
		</th>
		<th>
			可变
		</th>	
		<th>
			可变
		</th>
	</tr>
</table>

三种内存分配的方式：

**从静态存储区分配：**

内存在程序编辑的时候已经分配好，在程序的运行期间都存在，例如全局变量，静态变量。

**在栈上创建：**

在执行函数的时候，函数内部的局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会自动被释放。
栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限。（图中可以看出，栈内存是向低地址扩展，所以总可用地址固定）

**从堆上分配：**

亦称为动态内存分配。
程序在运行时使用malloc或者new申请任意多少的内存，程序员自己负责在何时用free或者delete来释放内存。
动态内存的生命周期由程序员决定，使用非常灵活，如果再堆上分配空间，既有责任回收它，否则运行的程序会有内存泄露，频繁的分配和释放不同大小的堆空间将会产生内存碎片。

**内存分配中堆和栈的区别**

- **管理方式不同：**栈是由编译器自动申请和释放空间，堆是需要程序员手动申请和释放。

- **空间大小不同：**栈的空间是有限的，在32位平台下，VC6下默认为1M, 栈的剩余空间足够，分配空间，否则抛出异常。堆遍历空间的内存地址链表，找到大于申请空间的堆节点，然后从空闲节点链表中删除节点，分配空间。堆最大可以到4G。

- **生长方向不同：**堆的生长方向是从低地址向高地址生长，更加灵活。栈向低地址扩展，所以最大容量固定。

- **分配方式不同：**堆都是动态分配的，没有静态分配的堆。栈有静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloc函数进行分配，但是栈的动态分配和堆的分配是不同的，它的动态分配是由编译器进行释放，无需手工实现。

- **分配效率不同：**栈的效率比堆高很多，栈的申请速度快。栈是机器系统提供的数据结构，计算机在底层提供栈的支持，分配专门的寄存器来存放栈的地址，压栈出栈都有相应的指令，因此比较快。堆是由库函数提供的，机制很复杂，库函数会按照一定的算法进行搜索内存，因此比较慢。

- **堆和栈中的存储内容：**栈：在函数调用的时候，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数时由右往左入栈（前面有解释)，然后是函数中的局部变量，静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令。堆：一般是在堆在头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。

- **堆和栈上的内存操作越界**：堆内存越界主要是操作的内存超过了malloc/new等在堆上分配内存函数所分配的大小，后果导致下次malloc/new的失败。栈内存越界的情况大多出现在对数组的操作上，数组下标超过了数组定义的长度，后果导致覆盖其他变量。

### C++对象的内存模型
类是创建对象的模板，不占用内存空间，不存在于编译后的可执行文件中；而对象是实实在在的数据，需要内存来存储。对象被创建时会在栈区或者堆区分配内存。

<font color =red>编译器会将成员变量和成员函数分开存储：分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码。</font>

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/10.png)

**成员变量在堆区或栈区分配内存，成员函数在代码区分配内存。**

### C++函数调用过程
函数调用时，第一个进栈的是主函数中的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的c编辑器中，参数是**从右往左入栈**的，然后是函数中的局部变量。本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

## <p id="C++类型转换">C++类型转换</p>

### C的类型转换
C语言类型转换主要有两种，隐式转换以及显式转换。
<pre>
//隐式转换
double f = 1.0/2;
//显式类型转换，格式为（类型说明符）（表达式）
double f = double(1)/double(2);
</pre>
**C语言类型转换的问题：**
1. 任意类型之间都可以转换，编译器无法判断其正确性。
2. 难于定位，在源码中无法快速定位。

### C++的类型转换
C++的类型转换主要有四种static\_cast, dynamic\_cast, const\_cast, reinterpret\_cast。

使用C++类型转换的优势在于：

1. C-Like的cast极具破坏性并且在代码文本上也难得花不少力气搜索到它；
2. 新式的cast使得程序员更有目的使用它们并且让编译器能够发现更多的错误；
3. 新的cast符合模板声明规范，可以让程序员编写它们自己的cast。

### const_cast

**用于转换指针或者引用，去掉类型的const属性**
主要是用来修改类型的const/volatile属性。除了const或者volatile属性外，目标类型必须与源类型相同。这种类型的转换主要是用来操作所传对象的const属性，可以加上const属性，也可以去掉const属性。
<pre>
const int val = 233; //声明为常量类型
int& use_val = const_cast<int&>(val); //使用去const引用
int* ptr_val = const_cast<int*>(val); //使用去const指针
</pre>

### static_cast

**用于基本类型转换，有继承关系类对象和类指针之间的转换，由程序员来确保转换是安全的，它不会产生动态类型转换的类型安全检查开销。**

static\_cast运算符执行非动态转换，没有运行时类检查来保证转换的安全性。主要用于基础的数据类型，以及同一个继承体系中的类型转换（上行转换：派生类指针转化为基类指针。是安全的，但是下行转换：基类指针转化为派生类指针，非动态转换，不能保证安全性）。
static\_cast 只能用于良性转换，这样的转换风险较低，一般不会发生什么意外，例如：

1. 原有的自动类型转换，例如 short 转 int、int 转 double、const 转非 const、向上转型等；
2. void 指针和具体类型指针之间的转换，例如void *转int *、char *转void *等；
3. 有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）。

static\_cast作用和C-Like强制转换效果基本一致，用于隐式转换，但是比起C-Like要安全一些。注意：

1. 不能在没有派生关系的两个类类型之间切换（相比之下，C-Like可以转换，实际上undefined，非常不安全，而static_cast会报错）。
2. 不能去除原有类型的类型修饰符，如const，volatile等。
3. 不能用于两个不相关类型转换，例如整形和整形指针之间的转换。虽然二者都为四个字节，但是一个表示数据，一个表示地址，类型不相关。
4. 转换对象时由于没有动态类型检查，所以由基类对象转化为派生类对象时存在隐患。
5. 不能用于两个具体类型指针之间的转换，例如int *转double *、Student *转int *等。不同类型的数据存储格式不一样，长度也不一样，用 A 类型的指针指向 B 类型的数据后，会按照 A 类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值。

<pre>
char c = 10; //一个字节
int* p = (int*)&c; // 4个字节
*p = 5; // 内存踩脏
int *q = static_cast<int*>(&c); //使用static_cast可以在编译阶段将错误检测出来。
</pre>
下面的代码可以更好地演示static\_cast的用法：

<pre>
class Complex{
public:
    Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag){ }
public:
    operator double() const { return m_real; }  //类型转换函数
private:
    double m_real;
    double m_imag;
};
int main(){
    //下面是正确的用法
    int m = 100;
    Complex c(12.5, 23.8);
    long n = static_cast<long>(m);  //宽转换，没有信息丢失
    char ch = static_cast<char>(m);  //窄转换，可能会丢失信息
    int *p1 = static_cast<int*>( malloc(10 * sizeof(int)) );  //将void指针转换为具体类型指针
    void *p2 = static_cast<void*>(p1);  //将具体类型指针，转换为void指针
    double real= static_cast<double>(c);  //调用类型转换函数
   
    //下面的用法是错误的
    float *p3 = static_cast<float*>(p1);  //不能在两个具体类型的指针之间进行转换
    p3 = static_cast<float*>(0X2DF9);  //不能将整数转换为指针类型
    return 0;
}
</pre>
### dynamic_cast

**只能用于含有虚函数的类，必须用在多态体系中，用于类层次间的向上和向下转换；向下转换时，如果是非法的，对于指针返回NULL。**

dynamic\_cast在运行时执行转换，验证转换的有效性，如果转换未执行，则转换失败，表达式expr被判定为null，dynamic\_cast执行动态转换时，type必须是类的指针，类的引用或者void*，如果type是类指针类型，那么expr也必须是一个指针，如果type是一个引用，那么expr也必须是一个引用。

dynamic\_cast的使用主要在downcast场景，它的使用主要需要满足两个条件：

1. downcast时转换的类之间存在“虚继承”关系。
2. 转换之后的类型与其指向的实际类型要相符合。dynamic\_cast在upcast与static\_cast效果是一样的，但是dynamic\_cast依赖于RTTI（Run-Time Type Identification)，开销会大一些。

dynamic\_cast 的语法格式为：
<pre>
dynamic_cast <newType> (expression)
</pre>
newType 和 expression 必须同时是指针类型或者引用类型。换句话说，dynamic_cast 只能转换指针类型和引用类型，其它类型（int、double、数组、类、结构体等）都不行。

对于指针，如果转换失败将返回 NULL；对于引用，如果转换失败将抛出std::bad_cast异常。

1. **向上转换**

	向上转型时，只要待转换的两个类型之间存在继承关系，并且基类包含了虚函数（这些信息在编译期间就能确定），就一定能转换成功。因为向上转型始终是安全的，所以 dynamic\_cast 不会进行任何运行期间的检查，这个时候的 dynamic\_cast 和 static\_cast 就没有什么区别了。**但是这样依旧会存在一些问题：**
	<pre>
	class Base{
	public:
	    Base(int a = 0): m_a(a){ }
	    int get_a() const{ return m_a; }
	    virtual void func() const { }
	protected:
	    int m_a;
	};
	class Derived: public Base{
	public:
	    Derived(int a = 0, int b = 0): Base(a), m_b(b){ }
	    int get_b() const { return m_b; }
	private:
	    int m_b;
	};
	int main(){
	    //情况1
	    Derived *pd1 = new Derived(35, 78);
	    Base *pb1 = dynamic_cast<Derived*>(pd1);
	    cout<< "pd1 = "<< pd1<< ", pb1 = "<< pb1<< endl;
	    cout<< pb1->get_a()<< endl;
	    pb1->func();
	    //情况2
	    int n = 100;
	    Derived *pd2 = reinterpret_cast<Derived*>(&n);
	    Base *pb2 = dynamic_cast<Base*>(pd2);
	    cout<< "pd2 = "<< pd2<< ", pb2 = "<< pb2<< endl;
	    cout<< pb2->get_a()<< endl;  //输出一个垃圾值
	    pb2->func();  //内存错误
	    return 0;
	}
	</pre>
	
	情况1是正确的，没有任何问题。对于情况2，pd 指向的是整型变量 n，并没有指向一个 Derived 类的对象，在使用 dynamic\_cast 进行类型转换时也没有检查这一点，而是将 pd 的值直接赋给了 pb（这里并不需要调整偏移量），最终导致 pb 也指向了 n。因为 pb 指向的不是一个对象，所以get\_a()得不到 m\_a 的值（实际上得到的是一个垃圾值），pb2->func()也得不到 func() 函数的正确地址。
	
	pb2->func()得不到 func() 的正确地址的原因在于，pb2 指向的是一个假的“对象”，它没有虚函数表，也没有虚函数表指针，而 func() 是虚函数，必须到虚函数表中才能找到它的地址。

2. **向下转换**
	
	向下转型是有风险的，dynamic_cast 会借助 RTTI 信息进行检测，确定安全的才能转换成功，否则就转换失败。那么，哪些向下转型是安全地呢，哪些又是不安全的呢？下面我们通过一个例子来演示：
	
	<pre>
	class A{
	public:
	    virtual void func() const { cout<< "Class A"<< endl; }
	private:
	    int m_a;
	};
	class B: public A{
	public:
	    virtual void func() const { cout<< "Class B"<< endl; }
	private:
	    int m_b;
	};
	class C: public B{
	public:
	    virtual void func() const { cout<< "Class C"<< endl; }
	private:
	    int m_c;
	};
	class D: public C{
	public:
	    virtual void func() const { cout<< "Class D"<< endl; }
	private:
	    int m_d;
	};
	int main(){
	    A *pa = new A();
	    B *pb;
	    C *pc;
	   
	    //情况1
	    pb = dynamic_cast<B*>(pa);  //向下转型失败
	    if(pb == NULL){
	        cout<< "Downcasting failed: A* to B*"<< endl;
	    }else{
	        cout<< "Downcasting successfully: A* to B*"<< endl;
	        pb -> func();
	    }
	    pc = dynamic_cast<C*>(pa);  //向下转型失败
	    if(pc == NULL){
	        cout<< "Downcasting failed: A* to C*"<< endl;
	    }else{
	        cout<< "Downcasting successfully: A* to C*"<< endl;
	        pc -> func();
	    }
	   
	    cout<< "-------------------------"<< endl;
	   
	    //情况2
	    pa = new D();  //向上转型都是允许的
	    pb = dynamic_cast<B*>(pa);  //向下转型成功
	    if(pb == NULL){
	        cout<< "Downcasting failed: A* to B*"<< endl;
	    }else{
	        cout<< "Downcasting successfully: A* to B*"<< endl;
	        pb -> func();
	    }
	    pc = dynamic_cast<C*>(pa);  //向下转型成功
	    if(pc == NULL){
	        cout<< "Downcasting failed: A* to C*"<< endl;
	    }else{
	        cout<< "Downcasting successfully: A* to C*"<< endl;
	        pc -> func();
	    }
	   
	    return 0;
	}
	</pre>
	
	运行结果
	<pre>
	Downcasting failed: A* to B*
	Downcasting failed: A* to C*
	-------------------------
	Downcasting successfully: A* to B*
	Class D
	Downcasting successfully: A* to C*
	Class D
	</pre>
	
	这段代码中类的继承顺序为：A --> B --> C --> D。pa 是A\*类型的指针，当 pa 指向 A 类型的对象时，向下转型失败，pa 不能转换为B\*或C\*类型。当 pa 指向 D 类型的对象时，向下转型成功，pa 可以转换为B\*或C\*类型。
	
	有虚函数存在时对象的真实内存模型中，每个类都会在内存中保存一份类型信息，编译器会将存在继承关系的类的类型信息使用指针“连接”起来，从而形成一个继承链（Inheritance Chain），也就是如下图所示的样子：
	
	![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/11.jpg)
	
	当使用 dynamic\_cast 对指针进行类型转换时，程序会先找到该指针指向的对象，再根据对象找到当前类（指针指向的对象所属的类）的类型信息，并从此节点开始沿着继承链向上遍历，如果找到了要转化的目标类型，那么说明这种转换是安全的，就能够转换成功，如果没有找到要转换的目标类型，那么说明这种转换存在较大的风险，就不能转换。
	
	对于本例中的情况1，pa 指向 A 类对象，根据该对象找到的就是 A 的类型信息，当程序从这个节点开始向上遍历时，发现 A 的上方没有要转换的 B 类型或 C 类型（实际上 A 的上方没有任何类型了），所以就转换败了。对于情况2，pa 指向 D 类对象，根据该对象找到的就是 D 的类型信息，程序从这个节点向上遍历的过程中，发现了 C 类型和 B 类型，所以就转换成功了。
	
	总起来说，dynamic\_cast 会在程序运行过程中遍历继承链，如果途中遇到了要转换的目标类型，那么就能够转换成功，如果直到继承链的顶点（最顶层的基类）还没有遇到要转换的目标类型，那么就转换失败。对于同一个指针（例如 pa），它指向的对象不同，会导致遍历继承链的起点不一样，途中能够匹配到的类型也不一样，所以相同的类型转换产生了不同的结果。
	
	从表面上看起来 dynamic\_cast 确实能够向下转型，本例也很好地证明了这一点：B 和 C 都是 A 的派生类，我们成功地将 pa 从 A 类型指针转换成了 B 和 C 类型指针。但是从本质上讲，dynamic\_cast 还是只允许向上转型，因为它只会向上遍历继承链。造成这种假象的根本原因在于，派生类对象可以用任何一个基类的指针指向它，这样做始终是安全的。本例中的情况②，pa 指向的对象是 D 类型的，pa、pb、pc 都是 D 的基类的指针，所以它们都可以指向 D 类型的对象，dynamic\_cast 只是让不同的基类指针指向同一个派生类对象罢了。

### reinterpret_cast

**重新解释类型，既不检查指向的内容，也不检查指针类型本身，但要求转换前后的类型所占用内存大小一致，否则将会引发编译时错误。**

reinterpret 是“重新解释”的意思，顾名思义，reinterpret\_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。

reinterpret\_cast运算符把某种指针改为其他类型的指针，他可以把一个指针转换为一个整数，也可以把一个整数转换为一个指针。对应于C中的强制类型转换，处理无法进行隐式转换的情况。但是也相当危险，容易出现错误。

<pre>
class A{
public:
    A(int a = 0, int b = 0): m_a(a), m_b(b){}
private:
    int m_a;
    int m_b;
};
int main(){
    //将 char* 转换为 float*
    char str[]="http://c.biancheng.net";
    float *p1 = reinterpret_cast<float*>(str);
    cout<< *p1<< endl;
    //将 int 转换为 int*
    int *p = reinterpret_cast<int*>(100);
    //将 A* 转换为 int*
    p = reinterpret_cast<int*>(new A(25, 96));
    cout<< *p<< endl;
   
    return 0;
}
</pre>

输出结果：
<pre>
3.0262e+29
25
</pre>

可以想象，用一个 float 指针来操作一个 char 数组是一件多么荒诞和危险的事情，这样的转换方式不到万不得已的时候不要使用。将A\*转换为int\*，使用指针直接访问 private 成员刺穿了一个类的封装性，更好的办法是让类提供 get/set 函数，间接地访问成员变量。

## <p id="C++static">C++ static</p>
### <p id="C++中static的作用">C++中static的作用</p>

1. static修饰的静态局部变量只初始化一次，延长局部变量的生命周期。（并不会随着实例的释放而消失，而是根据类对象的生命周期。）
2. static修饰的全局变量（函数）只能在本文件中访问。保证了安全性。如果要让其他文件调用全局变量，用extern语句。
3. 当变量不想被释放时使用static语句修饰，例如修饰函数中存放在栈空间的数组.
4. 保证了数据安全性。

### <p id="static存放的数据位置">static存放的数据位置</p>
全局（静态）存储区：分为DATA段和BSS段。

DATA段（全局初始化区）存放初始化的全局变量和静态变量。

BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。未初始化的全局变量和静态变量在程序执行之前被清0。

由于静态数据成员要在程序一开始运行时就必须存在，因为函数在程序运行时被调用，**所以静态数据成员不能在任何函数内分配空间和初始化。**

优势：可以节省内存，对所有对象是公有的。对多个对象来说，静态数据成员只存储一处，对所有成员共用。

### <p id="全局变量和全局静态变量区别">全局变量和全局静态变量区别</p>
**全局变量**是不显式用static修饰的全局变量，默认是具有外部链接性的，作用于是整个工程。在一个文件内定义的全局变量，在另一个文件中，可以通过extern全局变量名的声明来使用。

**全局静态变量**是显式使用static修饰的全局变量，作用域是声明变量所在的文件，其他文件的extern声明也不能调用，但是其他文件可以声明相同名字的全局变量，互不打扰。

**全局静态变量和全局变量都在全局存储区。**

### <p id="局部变量和静态局部变量区别">局部变量和静态局部变量区别</p>

- 静态局部变量是属于**全局存储器**的，而函数内部的局部变量属于**栈区**。
- 静态局部变量在该函数调用结束时，不会销毁，而是随着整个程序结束而结束，其他的函数调用不了该变量，局部变量该随着函数的结束而结束。
- 静态局部变量会自动初始化为0，而局部变量会初始化为一个随机值。
- 静态局部变量在编译期间只赋值一次，以后每次函数调用时，不在赋值，调用上次函数调用结束时的值。局部变量在调用期间，每调用一次，赋值一次。

### <p id="static用法">static用法</p>
**static关键字最基本的用法：**

- 被static修饰的变量属于类变量，可以通过类名.变量名直接引用，而不需要new出一个类来。
- 被static修饰的方法属于类方法，可以通过类名.方法名直接引用，而不需要new出一个类来。

在C++中，静态成员属于整个类而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它，**使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。**

### <p id="static成员函数函数相关">static成员函数函数相关</p>

- 不能通过类名来调用类的非静态成员函数。可以通过类的对象调用静态成员函数和非静态成员函数。
- 类的对象可以使用静态成员函数和非静态成员函数。在类的静态成员函数中不能使用类的非静态成员。静态成员函数属于整个类，在类实例化对象之前就已经分配空间了，而类的非静态成员必须在类实例化对象化后才有内存空间。
- 静态成员函数中不能引用非静态成员，在类的非静态成员函数中使用类的静态成员。
- 类的非静态成员函数可以调用用静态成员函数，但反之不能。
- 类的静态成员变量必须先初始化再使用。

编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。

普通成员变量占用对象的内存，静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。

普通成员函数必须通过对象才能调用，而静态成员函数没有 this 指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。

**静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。**
## <p id="C++const">C++ const</p>
<pre>
const int m=10;
int n = m;
</pre>
以上两行在C语言和C++中有区别，在C中编译器不会优化过程，会首先去m的内存取出数据，在进行赋值，在C++中，更类似于#define操作，直接为n赋值10。 但是与#define操作不同的是，该操作发生在编译期间，#define操作发生在预编译期间。

**C++的const操作减少了读取内存的过程，优点是提高了程序的执行效率，但是不能反应内存的变化，一旦const变量被修改，C++不能获取最新的值。**

<pre>
int main() {
	int p = 10;
	cout << "p: " << p << " &p: " << &p << endl;
	int* t1 = &p;
	*t1 = 11;
	cout << "p: " << p << " &p: " << &p << endl;
	cout << "t1: " << t1 << " &t1: " << &t1 << " *t1: " << *t1 << endl;
	const int p2 = 10;
	cout << "p2: " << p2 << " &p2: " << &p2 << endl;
	int* t2 = (int*)&p2;
	*t2 = 11;
	cout << "p2: " << p2 << " &p2: " << &p2 << endl;
	cout << "t2: " << t2 << " &t2: " << &t2 << " *t2: " << *t2 << endl;
	return 0;
}
</pre>
以上程序的输出为：
<pre>
p: 10 &p: 00EFFC7C
p: 11 &p: 00EFFC7C
t1: 00EFFC7C &t1: 00EFFC70 *t1: 11
p2: 10 &p2: 00EFFC64
p2: 10 &p2: 00EFFC64
t2: 00EFFC64 &t2: 00EFFC58 *t2: 11
</pre>
可以看到，虽然p2输出的还是10，但是其地址中所保存的值已经变为了11。这是极度不安全的，因为编译器对整个程序进行了优化，导致在编译期间所有的p2都直接替换为了10。但是实际上p2所保存的值现在为11。这带来了很大的不确定性。

**C和C++中全局 const 变量的作用域相同，都是当前文件，不同的是它们的可见范围：C语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而C++中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见，所以它可以定义在头文件中，多次引入后也不会出错。**

const是constant的缩写，在C++中用来修饰内置类型变量，自定义变量，成员函数，返回值，函数参数。

- const修饰指针指向的内容，则内容为不可变量。
- const修饰指针，则指针为不可变量。
- const修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。
- const int \*p =8;则指针指向的内容8不可改变。简称左定值，因为const位于*号的左边。

<pre>
int a = 8;
int* const p = &a;
*p = 9; //正确
int b = 7;
p = &b; //错误
</pre>
对于const指针p其指向的内存地址不能够被改变，其内容可以改变，简称右定向。因为const位于\*号的右边。对于以下，就是A和B的合并。
<pre>
int a =8;
const int * const p = &a;
</pre>
根据const位于\*号位置不同，**“左定值，右定向，const修饰不变量”。**

### <p id="const修饰函数参数">当const修饰函数参数时</p>
const修饰函数参数可以分为以下三种情况。

- 值传递的const修饰传递，一般这种情况不需要const修饰，因为函数会自动产生临时变量复制实参值。
- 当const参数为指针时，可以防止指针被意外篡改。
- 自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取const外加引用传递的方法。

### <p id="const成员函数">const成员函数（常成员函数）</p>

在类中将成员函数修饰为const表明在该函数体内， 不**能修改对象的数据成员而且不能调用非const函数**。

const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。const 成员函数也称为常成员函数。

我们通常将 get 函数设置为常成员函数。读取成员变量的函数的名字通常以get开头，后跟成员变量的名字，所以通常将它们称为 get 函数。

常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字，请看下面的例子：
<pre>
class Student{
public:
    Student(char *name, int age, float score);
    void show();
    //声明常成员函数
    char *getname() const;
    int getage() const;
    float getscore() const;
private:
    char *m_name;
    int m_age;
    float m_score;
};
</pre>
### <p id="const修饰返回值">const修饰返回值</p>
也是用const来修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改，也常用于运算符重载。归根究底就是 使得函数调用表达式不能作为左值。
<pre> 
class A {  
private:  
    int i;  
public:  
    A(){i=0;}  
    int & get(){  
        return i;  
    }  
};  
  
void main(){  
    A a;  
    cout<< a.get()<< endl; //数据成员值为0  
    a.get()=1; //尝试修改a对象的数据成员为1，而且是用函数调用表达式作为左值。  
    cout<< a.get()<< endl; //数据成员真的被改为1了，返回指针的情况也可以修
	//改成员i的值，所以为了安全起见最好在返回值加上const，使得函数调用表达式不能作为左值.  
}  
</pre>

**最后再来区分一下 const 的位置：**

- 用const修饰函数的参数，防止传入的参数代表的内容在函数体内被改变，但仅对指针和引用有意义。
- 函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如const char * getname()。
- 函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如char * getname() const。
## <p id="C++多态">C++多态</p>
C++多态分为**静态多态**和**动态多态**。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/11.png)

### <p id="C++静态多态">C++静态多态</p>
在编译期间的多态，编译器在**编译**期间完成的，编译器根据函数实参的类型，可推断出可能调用的函数，如果存在对应函数就调用，如果不存在，出现编译错误。静态多态的实现通过**函数重载**和**函数模板**使用。

**函数重载：**
在同一个作用域中，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（参数的个数，种类，顺序）必须有所差异，**不能仅通过返回类型的不同来重载函数。**
函数的重载的规则：

- 函数名称必须相同。
- 参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。
- 函数的返回类型可以相同也可以不相同。
- 仅仅返回类型不同不足以成为函数的重载。


发生函数调用时编译器会根据传入的实参的个数、类型、顺序等信息去匹配要调用的函数，这在大部分情况下都能够精确匹配。但当实参的类型和形参的类型不一致时情况就会变得稍微复杂，例如函数形参的类型是int，调用函数时却将short类型的数据交给了它，编译器就需要先将short类型转换为int类型才能匹配成功。但是转换要遵循以下规则，否则会编译报错。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/12.png)

如果在一个优先级中找到多个（两个以及以上）合适的重载函数，编译器就会陷入两难境地，不知道如何抉择，编译器会将这种模棱两可的函数调用视为一种错误，因为这些合适的重载函数同等“优秀”，没有一个脱颖而出，调用谁都一样。这就是函数重载过程中的二义性错误。

**函数模板：**
函数模板是通用的函数描述，也就是说，使用泛型来定义函数，其中泛型可用具体的类型（int, double等）替换，通过将类型作为参数，传递给模板，可以使编译器生成该类型的函数。

C++中，数据类型可以通过参数来传递，在函数定义的时候可以不指明具体的数据类型，当发生函数调用时，编译器可以根据传入的实参自动推断数据类型。
所谓函数模板，实际上是建立一个通用函数，它用到的数据类型，包括返回值类型，形参类型，局部变量类型可以不具体制定，而是用一个虚拟的类型来代替，等发生函数调用时再根据传入的实参来逆推出真正的类型。这个通用函数成为函数模板。

**类模板**

C++除了支持函数末班，还支持类模板，声明类模板的语法为：
<pre>
template<typename 类型参数1, typename 类型参数2, ...>class 类名{
	//TODO;
}；
</pre>

一旦声明了类模板，就可以将类型参数用于类的成员函数和成员变量了，换句话说，原来使用int，float等内置的地方，都可以用类型参数来代替。

**C++运算符重载**

重载的运算符是带有特殊名称的函数，函数名是由关键字operator和其后面要重载的运算符符号构成的。与其他函数一样，重载运算符要有一个返回类型和一个参数列表啊。
<pre>
Box operator+(const Box&, const Box&);
</pre>
下面是可重载的运算符列表：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/13.png)

下面是不可重载的运算符列表：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/14.png)

### <p id="C++动态多态">C++动态多态</p>
**虚函数与纯虚函数**
C++动态多态主要是通过**虚函数**来实现的。虚函数是在基类中使用关键字virtual声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接（早绑定）到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数（重写，函数参数，返回值类型必须一致），这种操作也被成为**动态链接**，或者**后期绑定**。

<pre>
class CDerived1: public CBase {};
class CDerived2: public CBase {};
int main() {
	CDerived1* pD1 = new CDerived1; //pD1的静态类型是CDerived1*，动态类型也是CDerived1*
	CBase* pBase = pD1; //pBase的静态类型是CBase*，动态类型是CDerived1*
	CDerived2* pD2 = new CDerived2; //pD2的静态类型是CDerived2*，动态类型也是CDerived2*
	pBase = pD2; //pBase的静态类型是CBase*，动态类型是CDerived2*
	return 0;
}
</pre>

如果想在基类中定义虚函数，以便在派生类中重新定义该函数更好的适用于对象，但是在基类中又不能对虚函数给出有意义的实现，这时候就会用到纯虚函数。
<pre>
//pure virtual function
virtual int area() = 0;
</pre>
**下面是构成多态的条件：**

- 必须存在继承关系；
- 继承关系中必须有同名的虚函数，并且它们是覆盖关系（函数原型相同）。
- 存在基类的指针，通过该指针调用虚函数

<pre>
//基类Base
class Base{
public:
    virtual void func();
    virtual void func(int);
};
void Base::func(){
    cout<< "void Base::func()"<< endl;
}
void Base::func(int n){
    cout<< "void Base::func(int)"<< endl;
}
//派生类Derived
class Derived: public Base{
public:
    void func();
    void func(char *);
};
void Derived::func(){
    cout<< "void Derived::func()"<< endl;
}
void Derived::func(char *str){
    cout<< "void Derived::func(char *)"<< endl;
}
int main(){
    Base *p = new Derived();
    p -> func();  //输出void Derived::func()
    p -> func(10);  //输出void Base::func(int)
    p -> func("http://c.biancheng.net");  //compile error
    return 0;
}
</pre>

在基类 Base 中我们将void func()声明为虚函数，这样派生类 Derived 中的void func()就会自动成为虚函数。p 是基类 Base 的指针，但是指向了派生类 Derived 的对象。

语句p -> func();调用的是派生类的虚函数，构成了多态。

语句p -> func(10);调用的是基类的虚函数，因为派生类中没有函数覆盖它。

**语句p -> func("http://c.biancheng.net");出现编译错误，因为通过基类的指针只能访问从基类继承过去的成员，不能访问派生类新增的成员。**

### <p id="静态多态动态多态优缺点">静态多态动态多态优缺点</p>

**静态多态**

**优点**

- 由于静态多态是编译期间完成的，因此效率较高，编译器也可以进行优化。
- 有很强的适配性和松耦合性，比如可以通过偏特化，全特化来处理特殊类型。
- 模板编程为C++带来了泛型设计的概念，这在STL库中得到淋漓尽致的体现。

**缺点**

- 由于是模板来实现静态多态，因此模板的不足也就是静态多态的劣势，比如调试困难，编译耗时，代码膨胀，编译器支持的兼容性。
- 不能够处理异质对象集合。

**动态多态**

**优点**
实现接口分离，可复用。
处理同一继承体系下异质对象集合的强大威力。
缺点
运行期间绑定，导致一定程度的运行时开销。
编译器无法对虚函数进行优化。
对接口的修改影响整个类层次。

**override和final**

**override：**

override是用来检查函数是否重写，在virtual void fun() override {}这里加上，然后来进行检查。

override作用:

1. 在函数比较多的情况下可以提示读者某个函数重写了基类虚函数（表示这个虚函数是从基类继承，不是派生类自己定义的）；
2. 强制编译器检查某个函数是否重写基类虚函数，如果没有则报错。


**final：**
final是在class A final {};这里加上，表示这个类不能被重写。可以提高性能。

**析构函数重写问题**

基类中析构函数如果是虚函数，那么派生类的析构函数就重写了基类的析构函数。虽然看似函数名不同，违背了重写的规则。其实可以理解为编译器对析构函数名称做了特殊处理，编译后析构函数名称统一为destructor。

### <p id="C++子类继承和调用父类的构造函数方法">C++子类继承和调用父类的构造函数方法</p>

构造方法用来初始化类的对象，与父类的其他成员不同，它不能被子类继承（子类可以继承父类所有的成员变量和成员方法，但是不能继承父类的构造方法）。因此，在创建子类对象时，为了初始化从父类继承来的数据对象，系统需要调用其父类的构造方法。如果没有显式的构造函数，编译器会给一个默认的构造函数，并且**该默认的构造函数仅仅在没有显式地声明构造函数情况下创建**。

**构造函数原则如下：**

- 如果子类没有定义构造函数，则调用父类的无参数的构造方法。
- 如果子类定义了构造方法，无论无参数还是带参数，在创建子类的对象的时候，首先执行父类无参数的构造方法，然后执行自己的构造方法。
- 创建子类对象的时候，如果子类的构造函数没有显式调用父类的构造函数，将会调用父类的默认无参数构造函数。
- 在创建子类的对象时候，如果子类的构造函数没有显式调用父类的构造函数且父类提供了无参数构造函数，则会调用父类自己的无参数构造函数。
- 在创建子类的时候，如果子类的构造函数没有显式调用父类的构造函数且父类只定义了自己的有参数构造函数，则会出错（如果父类只有有参数的构造方法，子类必须显式调用此方法）。

### <p id="C++虚函数原理">C++虚函数原理</p>
如果一个类包含了虚函数，那么在**编译期**创建**该类的对象时就会额外地增加一个数组（该数组针对类而非对象）**，数组中的每一个元素都是虚函数的入口地址。不过数组和对象是分开存储的，为了将对象和数组关联起来，编译器还要在对象中安插一个指针，指向数组的起始位置。**这里的数组就是虚函数表**（Virtual function table），简写为vtable。
有一个基类Base，他声明了N个虚函数:
<pre>
class Base {
	public:
		virtual void Func1() {
			//Func1的实现代码
		}
		virtual void Func2() {
			//Func2的实现代码
		}
		//Func3, Func4等虚函数的实现
		virtual void FuncN() {
			//FuncN的实现代码
		}
};
</pre>
下面的Derived类继承了Base类，并且覆盖了除了Func2之外的所有其他虚函数。
<pre>
class Derived: public Base {
	public:
		virtual void Func1() {
			//Func1覆盖Base类的Func1代码
		}
		//除去Func2的其他所有虚函数的实现代码
		virtual void FuncN() {
			//FuncN覆盖Base类的FuncN代码
		}
};
</pre>

编译器见到这种继承层次结构后，知道Base定义了虚函数，并且在Deriverd类中覆盖了这些函数。在这种情况下，编译器将为了实现虚函数的基类和覆盖了虚函数的派生类分别创建了一个**虚函数表**，也就是Base和Derived类都有自己的虚函数表。实例化这些类的对象时，将创建一个隐藏的指针VFT*，他指向相应的VFT。可将VFT视为一个包含函数指针的静态数组，其中每个指针指向相应的虚函数，Base类和Derived类的虚函数表如下：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/15.png)

每个虚函数表都由函数指针组成，其中每个指针都指向相应虚函数的实现。在类Derived的虚函数表中，除了一个函数指针外，其他所有的函数指针都指向本地的虚函数实现。Derived没有覆盖Base::Func2，因此相应的虚函数指针指向Base类的Func2的实现。
### <p id="虚函数工作原理">虚函数工作原理</p>

编译器处理虚函数的方式是：给每个对象添加一个指针，存放了指向虚函数表的地址，虚函数表存储了为类对象进行声明的虚函数地址。比如基类对象包含一个指针，该指针指向基类所有虚函数的地址表，派生类对象将包含一个指向独立地址表的指针，如果派生类提供了虚函数的新定义，该虚函数表将保存新函数地址，如果派生类没有重新定义虚函数，该虚函数表将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址将被添加到虚函数表中，注意虚函数无论多少个都只需要在对象中添加一个虚函数表的地址。

调用虚函数时，程序将查看存储在对象中的虚函数表地址，转向相应的虚函数表，使用类声明中定义的第几个虚函数，程序就使用数组的第几个函数地址，并执行该函数。

**使用虚函数后的变化：**

- 对象将增加一个存储地址的空间（32位系统为4字节，64位系统为8字节）。
- 每个类编译器都将创建一个虚函数地址表。
- 对每个函数调用都需要增加在表中查找地址的操作。


**虚函数的注意事项：**

- 基类方法中声明了方法为虚后，该方法在基类派生类中是虚的。
- 若使用指向对象的引用或者指针调用虚方法，程序将根据对象类型来调用方法，而不是指针的类型。
- 如果定义的类被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚。
- **构造函数不能为虚函数**。
- 友元函数不能为虚，友元函数不是类成员，只有类成员才能是虚函数。
- 如果派生类没有重定义基类函数，则会使用基类版本，‘重新定义继承的方法如果和基类不同，会将基类方法隐藏，如果基类声明方法被重载，则派生类也需要对重载的方法进行重新定义，否则依旧调用基类方法。
## <p id="C++STL">C++ STL</p>

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/16.png)

STL即standard template library，中文可译为标准模板库或者泛型库，其中包含了大量的模板类和模板函数，是C++提供的一个基础模板集合。
相比原始方法，大多数操作细节不需要程序员去关心。例如，如果我们想要申请一个数组，原始方法如下：
<pre>
int a[n];
int* p = new int[n];
</pre>

第一种方法要事先确定数组的长度，n必须为常量，如果实际应用中无法确定长度，则一般设置为可能的最大值，但这极有可能造成存储空间的浪费。

第二种方法可以根据变量n动态申请内存，不会出现存储空间浪费的问题，但是，如果程序执行过程中出现空间不足的情况，需要加大存储空间，此时要执行以下操作：

申请一个较大的空间。
<pre>int * temp = new int[m];</pre>
将原空间内数据全部复制到新申请的空间中，执行
<pre>memecpy(temp, p, sizeof(int)*n);</pre>
将原来的空间释放掉，执行
<pre>delete [] p; 
p = temp;</pre>
而使用STL的标准库中的vector，就不需要关注如何实现扩容等操作。
<pre>
vector < int> a; //定义 a 数组，当前数组长度为 0，但和普通数组不同的是，此数组 a 可以根据存储数据的数量自动变长。
//向数组 a 中添加 10 个元素
for (int i = 0; i < 10 ; i++)
    a.push_back(i)
//还可以手动调整数组 a 的大小
a.resize(100);
a[90] = 100;
//还可以直接删除数组 a 中所有的元素，此时 a 的长度变为 0
a.clear();
//重新调整 a 的大小为 20，并存储 20 个 -1 元素。
a.resize(20, -1)
</pre>
STL是由**容器，算法，迭代器，函数对象，适配器，内存分配器**这6部分构成，其中后面4部分是为前面2部分服务的。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/17.png)

### <p id="STL容器与迭代器">STL容器与迭代器</p>
### STL容器

简单的理解容器，就是一些模板类的集合，但是和普通模板类不同的是，容器中封装的是组织数据的方法，也就是数据结构，STL提供3类标准容器，分别是**序列容器，排序容器和哈希容器**。后两者也统称为**关联容器**。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/18.png)

### STL迭代器

由于容器本质都是用来存储大量数据的，都是一串能够存储多个数据的存储单元，因此诸如数据的排序，查找，求和等对数据进行遍历的操作方法应该是类似的。于是可以使用泛化方法，将它们设计成适用于所有容器的通用算法。从而将容器和算法分离开。但是需要一个类似的中介装置，除了能**对容器进行遍历读写数据**之外，还要能**对外隐藏容器的内部差异，从而统一的界面向算法传递数据**（例如unordered_map，如果没有迭代器，无法对map中key进行遍历）。

**迭代器按功能强弱分为：输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机访问迭代器。**

**输入/输出迭代器：**该类型迭代器比较特殊，不是把数组或者容器作为操作对象，而是把输入流和输出流作为操作对象。

**前向迭代器：**假设p是一个前向迭代器，p支持++p，p++，*p操作，还可以别赋值或复制，可以用==和！=比较。

**双向迭代器：**在前向迭代器的基础上，还可以--p或者p--操作，（即一次向后移动一个位置）。

**随机迭代器：**除了支持双向迭代器所有功能，还支持：

- p+=i：使得 p 往后移动 i 个元素。
- p-=i：使得 p 往前移动 i 个元素。
- p+i：返回 p 后面第 i 个元素的迭代器。
- p-i：返回 p 前面第 i 个元素的迭代器。
- p[i]：返回 p 后面第 i 个元素的引用。

此外，两个随机迭代器还支持使用<,>,<=,>=等运算符进行比较（前向和双向不支持）。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/19.png)

### STL迭代器定义方式

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/20.png)

通过定义以上几种迭代器，就可以读取它指向的元素，*迭代器名就表示迭代器指向的元素。其中，常量迭代器和非常量迭代器的分别在于，通过非常量迭代器还能修改其指向的元素。另外，反向迭代器和正向迭代器的区别在于：

- 对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；
- 而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。

**注意，以上 4 种定义迭代器的方式，并不是每个容器都适用。**有一部分容器同时支持以上 4 种方式，比如 array、deque、vector；而有些容器只支持其中部分的定义方式，例如 forward_list 容器只支持定义正向迭代器，不支持定义反向迭代器。

**不是所有迭代器都有==以及!=等操作，例如反向迭代器就不支持。**

### STL迭代器使用举例

<pre>
int main()
{
    vector< int> v{1,2,3,4,5,6,7,8,9,10}; //v被初始化成有10个元素
    cout << "第一种遍历方法：" << endl;
    //size返回元素个数
    for (int i = 0; i < v.size(); ++i)
        cout << v[i] <<" "; //像普通数组一样使用vector容器
    //创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式
    
       cout << endl << "第二种遍历方法：" << endl;
       vector< int>::iterator i;
    //用 != 比较两个迭代器
    for (i = v.begin(); i != v.end(); ++i)
        cout << *i << " ";
    
       cout << endl << "第三种遍历方法：" << endl;
    for (i = v.begin(); i < v.end(); ++i) //用 < 比较两个迭代器
        cout << *i << " ";
   
       cout << endl << "第四种遍历方法：" << endl;
    i = v.begin();
    while (i < v.end()) { //间隔一个输出
        cout << *i << " ";
        i += 2; // 随机访问迭代器支持 "+= 整数"  的操作
    }
}
</pre>
运行结果为：
<pre>
第一种遍历方法：
1 2 3 4 5 6 7 8 9 10
第二种遍历方法：
1 2 3 4 5 6 7 8 9 10
第三种遍历方法：
1 2 3 4 5 6 7 8 9 10
第四种遍历方法：
1 3 5 7 9
</pre>
然而对于双向迭代器，例如list容器，我们执行以下操作：
<pre>
//创建一个 v list容器
list< int> v;
//创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式。
list< int>::const_iterator i;
//合法
for(i = v.begin(); i != v.end(); ++i)
    cout << *i;
//以下代码则不合法，因为双向迭代器不支持用“<”进行比较：
for(i = v.begin(); i < v.end(); ++i)
    cout << *i;
//以下代码也不合法，因为双向迭代器不支持用下标随机访问元素：
for(int i=0; i< v.size(); ++i)
    cout << v[i];
</pre>

### <p id="STL序列式容器">STL序列式容器</p>

STL序列式容器有array、vector、deque、list、forward_list。

他们的共同特点是**不会对存储的元素进行排序，元素排序的顺序取决于存储他们的顺序。**

- array<T,N>(数组容器)：表示可以存储N个T类型的元素，此类容器一旦创立，其长度无法改变。
- vector<T>(向量容器)：用来存放T类型的元素，长度可变的序列容器。在尾部增加删除元素的效率最高（O(1)），在其他位置为O(n)。
- deque<T><(双端队列容器)：与vector类似，该容器不仅可以尾部插入和删除，头部插入与删除元素一样高效，时间复杂度都是O(1)常数阶，其他位置O(n)。
- list<T>(链表容器)：长度可变的，由T类型元素组成的序列，他以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增删元素，但访问要慢很多。
- forward_list<T>(正向链表容器)：和list容器类似，只不过它以单链表的形式组织元素，内部元素只能从第一个元素开始访问，是一类比链表容器快，更节省内存的容器。
- stack<T>和queue<T>本质上也属于序列容器，在deque容器基础上进行修改。

下图说明可供使用的序列容器以及他们之间的关系：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/22.jpg)

### array

array容器就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全（原因后续会讲），且效率并没有因此变差。

和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，在使用该容器的过程无法借由增加或移除元素而改变其大小，它只允许访问或者替换存储的元素。

通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值：

<pre>
array<double, 10> values {};
</pre>
使用该语句，容器中所有的元素都会被初始化为 0.0。

当然，在创建 array 容器的实例时，也可以像创建常规数组那样对元素进行初始化：

<pre>
array<double, 10> values {0.5,1.0,1.5,,2.0};
</pre>
可以看到，这里只初始化了前 4 个元素，剩余的元素都会被初始化为 0.0。下图说明了这一点。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/21.png)

array 容器还提供有很多功能实用的成员函数，如下表展示：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/25.png)


**array对比C++普通数组的优势**

与C++普通数组存储方式一样，都是连续且相邻的内存中。但是array模板类中已经封装好了大量实用的方法，在提高开发效率的同时，代码运行效率也会大幅提升。比如at()成员函数能防止数组越界。

### Vector

与array类似，但是array是静态数组，vector实现的是一个动态数组。

使用vector<T> values;创建空容器，当添加第一个元素的时候，vector会自动分配内存，在创建好空容器基础上，可以使用reserve()函数来增加容器容量。例如values.reserve(20)。需要注意的是，如果vector容量已经大于等于20，则该语句不执行。另外reserve()不会影响已储存的元素，也不会生成任何元素，所以此时values仍没有任何元素。需要注意的是，**如果调用了reserve()来增加容器容量，之前创建好的任何迭代器都可能会失效（vector<T>容器的元素可能已经被复制移动到了新的内存地址），所以后续使用时要重新生成。**

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/23.png)

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/24.png)

vector包含的成员函数如下：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/26.png)

**Vector底层分析**

vector结构非常简单，只是一段连续的线性内存空间。vector是使用3个迭代器（指针）表示的：

<pre>
//_Alloc 表示内存分配器，此参数几乎不需要我们关心
template <class _Ty, class _Alloc = allocator<_Ty>>
class vector{
    ...
protected:
    pointer _Myfirst;
    pointer _Mylast;
    pointer _Myend;
};
</pre>

其中，\_Myfirst 指向的是 vector 容器对象的起始字节位置；\_Mylast 指向当前最后一个元素的末尾字节；\_myend 指向整个 vector 容器所占用内存空间的末尾字节。

下图演示了以上这 3 个迭代器分别指向的位置。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/27.png)

通过这 3 个迭代器，就可以表示出一个已容纳 2 个元素，容量为 5 的 vector 容器。

在此基础上，将 3 个迭代器两两结合，还可以表达不同的含义，例如：

- _Myfirst 和 _Mylast 可以用来表示 vector 容器中目前已被使用的内存空间；
- _Mylast 和 _Myend 可以用来表示 vector 容器目前空闲的内存空间；
- _Myfirst 和 _Myend 可以用表示 vector 容器的容量。

对于空的 vector 容器，由于没有任何元素的空间分配，因此 \_Myfirst、\_Mylast 和 \_Myend 均为 null。

通过灵活运用这 3 个迭代器，vector 容器可以轻松的实现诸如首尾标识、大小、容器、空容器判断等几乎所有的功能，比如：

<pre>
template < class _Ty, class _Alloc = allocator<_Ty>>
class vector{
public：
    iterator begin() {return _Myfirst;}
    iterator end() {return _Mylast;}
    size_type size() const {return size_type(end() - begin());}
    size_type capacity() const {return size_type(_Myend - begin());}
    bool empty() const {return begin() == end();}
    reference operator[] (size_type n) {return *(begin() + n);}
    reference front() { return *begin();}
    reference back() {return *(end()-1);}
    ...
};
</pre>

**vector扩大容量的本质**

另外需要指明的是，当vector的大小和容量相等（size==capacity）也就是满载时，如果再向添加元素，那么vector就需要扩容，vector扩容步骤分为以下三步：

- 完全弃用现有的内存空间，重新申请更大的内存空间。
- 将旧的内存空间中的数据，按原有顺序移动到新的内存空间中。
- 将旧的内存空间释放。

**所以当vector扩容后，与其相关的指针，引用和迭代器都有可能失效。
扩容大小一般为1.5~2倍。**

**emplace\_back()和push\_back()的区别**

emplace\_back()和push\_back()的区别，就在于底层实现的机制。push\_back()向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁前先创建的这个元素）；而emplace\_back()在实现时，**则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。**

**emplace()和insert()的区别**

insert()函数功能是在vector容器指定位置插入一个或多个元素，而emplace()一次只能在指定位置前插入一个元素。同样，emplace()函数的执行效率要比insert()函数要高。

**vector删除元素**

vector删除元素可以使用下表的函数或者函数组合。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/28.png)

<font color=red>**resize和reserve区别(重要):**</font>

vector的整个扩容过程非常耗时，还会引起该容器相关的所有指针，迭代器以及引用失效，所以在使用vector过程中，应该尽量避免不必要的扩容操作。要实现这个目的，可以借助reserve()函数。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/29.png)

当新元素添加到vector容器中而恰好此时vector容器的容量不足时，该容器会动态扩容。可以先使用reserve()初始化一个较大的容量，来避免多次动态扩容。

综上，reserve是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。加入新的元素时，要调用push\_back()/insert()/emplace\_back()函数。

resize是改变容器的大小，且在创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。此时再调用push\_back()函数，是加在这个新的空间后面的。

**swap()函数清除容量**

首先我们可以知道，上面所有删除元素都不会改变vector的容量，vector中有shrink_to_fit()函数可以将vector的容量缩减至和实际存储元素个数相等。除此之外我们也可以使用swap()函数去除多余容量。

<pre>vector<T>(x).swap(x);</pre>

大致执行思路是，先执行vector<T>(x)，使用拷贝构造函数，构造出一个临时的vector，并将x的元素拷贝到vector中，然后swap()函数交换临时的vector和x，容积也一同交换，最后析构掉临时vector，此时x容积为元素数量。用此方法甚至可以清空vector。

<pre>
vector<T>().swap(x).
</pre>

### deque

deque 是 double-ended queue 的缩写，又称双端队列容器。

deque 容器和 vecotr 容器有很多相似之处，比如：

- deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为O(1)），而不擅长在序列中间添加或删除元素。
- deque 容器也可以根据需要修改自身的容量和大小。

和 vector 不同的是，deque 还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常数阶O(1)。并且更重要的一点是，**deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。**

当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。

下图为deque可以使用的的成员函数

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/30.png)

和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数，同时删除了 capacity()、reserve() 和 data() 成员函数。

deque 容器迭代器的类型为随机访问迭代器，下图表示所支持迭代器的成员函数

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/31.png)

**deque容器的存储结构**

和 vector 容器采用连续的线性空间不同，deque 容器存储数据的空间是由一段一段等长的连续空间构成，各段空间之间并不一定是连续的，可以位于在内存的不同区域。

为了管理这些连续空间，deque 容器用数组（数组名假设为 map）存储着各个连续空间的首地址。也就是说，map 数组中存储的都是指针，指向那些真正用来存储数据的各个连续空间。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/32.png)

通过建立 map 数组，deque 容器申请的这些分段的连续空间就能实现“整体连续”的效果。换句话说，当 deque 容器需要在头部或尾部增加存储空间时，它会申请一段新的连续空间，同时在 map 数组的开头或结尾添加指向该空间的指针，由此该空间就串接到了 deque 容器的头部或尾部。

**deque容器迭代器的底层实现**

由于 deque 容器底层将序列中的元素分别存储到了不同段的连续空间中，因此要想实现迭代器的功能，必须先解决如下 2 个问题：

1. 迭代器在遍历 deque 容器时，必须能够确认各个连续空间在 map 数组中的位置；
1. 迭代器在遍历某个具体的连续空间时，必须能够判断自己是否已经处于空间的边缘位置。如果是，则一旦前进或者后退，就需要跳跃到上一个或者下一个连续空间中。

为了实现遍历 deque 容器的功能，deque 迭代器定义了如下的结构：

<pre>
template< class T,...>
struct __deque_iterator{
    ...
    T* cur;
    T* first;
    T* last;
    map_pointer node;//map_pointer 等价于 T**
}
</pre>

可以看到，迭代器内部包含 4 个指针，它们各自的作用为：

- cur：指向当前正在遍历的元素；
- first：指向当前连续空间的首地址；
- last：指向当前连续空间的末尾地址；
- node：它是一个二级指针，用于指向 map 数组中存储的指向当前连续空间的指针。

借助这 4 个指针，deque 迭代器对随机访问迭代器支持的各种运算符进行了重载，能够对 deque 分段连续空间中存储的元素进行遍历。例如：

<pre>
//当迭代器处于当前连续空间边缘的位置时，如果继续遍历，就需要跳跃到其它的连续空间中，该函数可用来实现此功能
void set_node(map_pointer new_node){
    node = new_node;//记录新的连续空间在 map 数组中的位置
    first = *new_node; //更新 first 指针
    //更新 last 指针，difference_type(buffer_size())表示每段连续空间的长度
    last = first + difference_type(buffer_size());
}
//重载 * 运算符
reference operator*() const{return *cur;}
pointer operator->() const{return &(operator *());}
//重载前置 ++ 运算符
self & operator++(){
    ++cur;
    //处理 cur 处于连续空间边缘的特殊情况
    if(cur == last){
        //调用该函数，将迭代器跳跃到下一个连续空间中
        set_node(node+1);
        //对 cur 重新赋值
        cur = first;
    }
    return *this;
}
//重置前置 -- 运算符
self& operator--(){
    //如果 cur 位于连续空间边缘，则先将迭代器跳跃到前一个连续空间中
    if(cur == first){
        set_node(node-1);
        cur == last;
    }
    --cur;
    return *this;
}

</pre>

**deque容器的底层实现**

deque 容器除了维护先前讲过的 map 数组，还需要维护 start、finish 这 2 个 deque 迭代器。以下为 deque 容器的定义：

<pre>
//_Alloc为内存分配器
template< class _Ty,
    class _Alloc = allocator< _Ty>>
class deque{
    ...
protected:
    iterator start;
    iterator finish;
    map_pointer map;
...
}

</pre>

其中，start 迭代器记录着 map 数组中首个连续空间的信息，finish 迭代器记录着 map 数组中最后一个连续空间的信息。另外需要注意的是，和普通 deque 迭代器不同，start 迭代器中的 cur 指针指向的是连续空间中首个元素；而 finish 迭代器中的 cur 指针指向的是连续空间最后一个元素的下一个位置。

因此，deque 容器的底层实现如下图所示。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/33.png)

借助 start 和 finish，以及 deque 迭代器中重载的诸多运算符，就可以实现 deque 容器提供的大部分成员函数，比如：

<pre>
//begin() 成员函数
iterator begin() {return start;}
//end() 成员函数
iterator end() { return finish;}
//front() 成员函数
reference front(){return *start;}
//back() 成员函数
reference back(){
    iterator tmp = finish;
    --tmp;
    return *tmp;
}
//size() 成员函数
size_type size() const{return finish - start;}//deque迭代器重载了 - 运算符
//enpty() 成员函数
bool empty() const{return finish == start;}
</pre>

往deque中添加或删除元素，可以借助deque模板类提供的成员函数。
    
![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/34.png)

### <p id="STLlist">STL list</p>

STL list 容器，又称**双向链表容器**，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。

下图展示了 list 双向链表容器是如何存储元素的。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/35.png)

可以看到，list 容器中各个元素的前后顺序是靠指针来维系的，每个元素都配备了 2 个指针，分别指向它的前一个元素和后一个元素。其中第一个元素的前向指针总为 null，因为它前面没有元素；同样，尾部元素的后向指针也总为 null。

基于这样的存储结构，list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，即它可以在序列已知的任何位置快速插入或删除元素（时间复杂度为O(1)）。并且在 list 容器中移动元素，也比其它容器的效率高。

使用 list 容器的缺点是，它不能像 array 和 vector 那样，通过位置直接访问元素。举个例子，如果要访问 list 容器中的第 6 个元素，它不支持容器对象名[6]这种语法格式，正确的做法是从容器中第一个元素或最后一个元素开始遍历容器，直到找到该位置。

实际场景中，如何需要对序列进行大量添加或删除元素的操作，而直接访问元素的需求却很少，这种情况建议使用 list 容器存储序列。

list所支持的迭代器如下：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/36.png)

list的迭代器与array, vector, deque不同，不支持随机访问，其迭代器类型为**双向迭代器。**

这意味着，假设 p1 和 p2 都是双向迭代器，则它们支持使用 ++p1、 p1++、 p1--、 p1++、 *p1、 p1==p2 以及 p1!=p2 运算符，但不支持以下操作（其中 i 为整数）：

- p1[i]：不能通过下标访问 list 容器中指定位置处的元素。
- p1-=i、 p1+=i、 p1+i 、p1-i：双向迭代器 p1 不支持使用 -=、+=、+、运算符。
- p1<p2、 p1>p2、 p1<=p2、 p1>=p2：双向迭代器 p1、p2 不支持使用 <、 >、 <=、 >= 比较运算符。

**list容器底层存储结构**

一些版本的STL中，list容器使用的双向链表，而在一些 STL 版本中（比如 SGI STL），list 容器的底层实现使用的是双向循环链表。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/37.png)

使用链表存储数据，并不会将它们存储到一整块连续的内存空间中。恰恰相反，各元素占用的存储空间（又称为节点）是独立的、分散的，它们之间的线性关系通过指针（上图以箭头表示）来维持。

**list 容器节点结构**

<pre>
template< typename T,...>
struct __List_node{
    //...
    __list_node<T>* prev;
    __list_node<T>* next;
    T myval;
    //...
}
</pre>

list 容器定义的每个节点中，都包含 *prev、*next 和 myval。其中，prev 指针用于指向前一个节点；next 指针用于指向后一个节点；myval 用于存储当前元素的值。

**list容器迭代器的底层实现**

和 array、vector 这些容器迭代器的实现方式不同，由于 list 容器的元素并不是连续存储的，所以该容器迭代器中，必须包含一个可以指向 list 容器的指针，并且该指针还可以借助重载的 *、++、--、==、!= 等运算符，实现迭代器正确的递增、递减、取值等操作。

<pre>
template<tyepname T,...>
struct __list_iterator{
    __list_node< T>* node;
    //...
    //重载 == 运算符
    bool operator==(const __list_iterator& x){return node == x.node;}
    //重载 != 运算符
    bool operator!=(const __list_iterator& x){return node != x.node;}
    //重载 * 运算符，返回引用类型
    T* operator *() const {return *(node).myval;}
    //重载前置 ++ 运算符
    __list_iterator< T>& operator ++(){
        node = (*node).next;
        return *this;
    }
    //重载后置 ++ 运算符
    __list_iterator< T>& operator ++(int){
        __list_iterator< T> tmp = *this;
        ++(*this);
        return tmp;
    }
    //重载前置 -- 运算符
    __list_iterator< T>& operator--(){
        node = (*node).prev;
        return *this;
    }
    //重载后置 -- 运算符
    __list_iterator< T> operator--(int){
        __list_iterator<T> tmp = *this;
        --(*this);
        return tmp;
    }
    //...
}
</pre>

可以看到，迭代器的移动就是通过操作节点的指针实现的。

**list容器的底层实现**

不同版本的 STL 标准库中，list 容器的底层实现并不完全一致，但原理基本相同。这里以 SGI STL 中的 list 容器为例，讲解该容器的具体实现过程。

SGI STL 标准库中，list 容器的底层实现为双向循环链表，相比双向链表结构的好处是在构建 list 容器时，只需借助一个指针即可轻松表示 list 容器的首尾元素。

如下是 SGI STL 标准库中对 list 容器的定义：

<pre>
template < class T,...>
class list
{
    //...
    //指向链表的头节点，并不存放数据
    __list_node<T>* node;
    //...以下还有list 容器的构造函数以及很多操作函数
}
</pre>

另外，为了更方便的实现 list 模板类提供的函数，该模板类在构建容器时，会刻意在容器链表中添加一个空白节点，并作为 list 链表的首个节点（又称头节点）。

使用双向链表实现的 list 容器，其内部通常包含 2 个指针，并分别指向链表中头部的空白节点和尾部的空白节点（也就是说，其包含 2 个空白节点）。

比如，我们经常构造空的 list 容器，其用到的构造函数如下所示：

<pre>
list() { empty_initialize(); }
// 用于空链表的建立
void empty_initialize()
{
    node = get_node();//初始化节点
    node->next = node; // 前置节点指向自己
    node->prev = node; // 后置节点指向自己
}
</pre>

显然，即便是创建空的 list 容器，它也包含有 1 个节点。

除此之外，list 模板类中还提供有带参的构造函数，它们的实现过程大致分为以下 2 步：

- 调用 empty_initialize() 函数，构造带有头节点的空 list 容器链表；
- 将各个参数按照次序插入到空的 list 容器链表中。

由此可以总结出，list 容器实际上就是一个带有头节点的双向循环链表。如图 2 所示，此为存有 2 个元素的 list 容器：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/38.png)

list 模板类中，与“添加或插入新元素”相关的成员方法有如下几个：

- push_front()：向 list 容器首个元素前添加新元素；
- push_back()：向 list 容器最后一个元素后添加新元素；
- emplace_front()：在容器首个元素前直接生成新的元素；
- emplace_back()：在容器最后一个元素后直接生成新的元素；
- emplace()：在容器的指定位置直接生成新的元素；
- insert()：在指定位置插入新元素；
- splice()：将其他 list 容器存储的多个元素添加到当前 list 容器的指定位置处。

list删除元素的方法如下：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/39.png)

**C++ forward_list**

与list一样采取链表形式，不过是单链表。比起list虽然操作不灵活，但是所需内存更少，空间利用率更高。

### <p id="STL关联式容器">STL关联式容器</p>

关联式容器与序列式容器不同，此类容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。

使用关联式容器存储的元素，都是一个一个的“键值对”（ <key,value> ），这是和序列式容器最大的不同。除此之外，序列式容器中存储的元素默认都是未经过排序的，而使用关联式容器存储的元素，默认会根据各元素的键值的大小做升序排序。

注意，关联式容器所具备的这些特性，归咎于 STL 标准库在实现该类型容器时，底层选用了**红黑树**这种数据结构来组织和存储各个键值对。

STL关联式容器的种类如下：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/40.png)

### STL map

作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 C++ 基本数据类型（int、double 等）、使用结构体或类自定义的类型。

与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用std::less< T>排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。当然，根据实际情况的需要，我们可以手动指定 map 容器的排序规则，既可以选用 STL 标准库中提供的其它排序规则（比如std::greater< T>），也可以自定义排序规则。

另外需要注意的是，**使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改。**换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。

**STL map使用的迭代器**

C++ STL 标准库为 map 容器配备的是双向迭代器（bidirectional iterator）。这意味着，map 容器迭代器只能进行 ++p、p++、--p、p--、*p 操作，并且迭代器之间只能使用 == 或者 != 运算符进行比较。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/41.png)

map 类模板中还提供有 lower_bound(key) 和 upper_bound(key) 成员方法，它们的功能是类似的，唯一的区别在于：

- lower_bound(key) 返回的是指向第一个键不小于 key 的键值对的迭代器；
- upper_bound(key) 返回的是指向第一个键大于 key 的键值对的迭代器；

**当实现“向 map 容器中添加新键值对元素”的操作时，insert() 成员方法的执行效率更高；而在实现“更新 map 容器指定键值对的值”的操作时，operator[ ] 的效率更高。**

原因在于使用 operator[ ] 添加新键值对元素的流程是，先构造一个有默认值的键值对，然后再为其 value 赋值。而insert是直接构造一个要添加元素的键值对元素。如下代码所示：
执行插入操作时，operator[ ]操作：

<pre>
mymap["STL教程"] = "http://c.biancheng.net/java/";
</pre>

等效于：
<pre>
typedef map< string, string> mstr;
//创建要添加的默认键值对元素
pair< mstr::iterator, bool>res = mymap.insert(mstr::value_type("STL教程", string()));
//将新键值对的值赋值为指定的值
res.first->second = "http://c.biancheng.net/java/";
</pre>

而与之相比，insert操作则是：
<pre>
mymap.insert(mstr::value_type("STL教程", "http://c.biancheng.net/java/"));
</pre>

对于更新操作。两者如下所示。
<pre>
//operator[]
mymap["STL教程"] = "http://c.biancheng.net/stl/";
//insert()
std::pair< string, string> STL = { "Java教程","http://c.biancheng.net/python/" };
mymap.insert(STL).first->second = "http://c.biancheng.net/java/";
</pre>

insert() 方法在进行更新操作之前，需要有一个 pair 类型（也就是 map::value_type 类型）元素做参数。这意味着，该方法要多构造一个 pair 对象（附带要构造 2 个 string 对象），并且事后还要析构此 pair 对象（附带 2 个 string 对象的析构），而和 insert() 方法相比，operator[ ] 就不需要使用 pair 对象，自然不需要构造（并析构）任何 pair 对象或者 string 对象。因此，对于更新已经存储在 map 容器中键值对的值，应优先使用 operator[ ] 方法。

使用 insert() 向 map 容器中插入键值对的过程是，先创建该键值对，然后再将该键值对复制或者移动到 map 容器中的指定位置；

**使用 emplace() 或 emplace_hint() 插入键值对的过程是，直接在 map 容器中的指定位置构造该键值对。所以实际使用时，建议使用emplace来进行插入。**

### STL multimap

multimap 容器具有和 map 相同的特性，即 multimap 容器也用于存储 pair<const K, T> 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，**multimap 容器中可以同时存储多（≥2）个键相同的键值对。**

### STL set和multiset

和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。

使用 set 容器存储的各个元素的值必须各不相同。更重要的是，从语法上讲 set 容器并没有强制对存储元素的类型做 const 修饰，即 set 容器中存储的元素的值是可以修改的。但是，C++ 标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，使得在正常情况下，用户是无法做到修改 set 容器中元素的值的。

set所具有的一些特性：

- 不再以键值对的方式存储数据，因为 set 容器专门用于存储键和值相等的键值对，因此该容器中真正存储的是各个键值对的值（value）；
- set 容器在存储数据时，会根据各元素值的大小对存储的元素进行排序（默认做升序排序）；
- 存储到 set 容器中的元素，虽然其类型没有明确用 const 修饰，但正常情况下它们的值是无法被修改的；
- set 容器存储的元素必须互不相等。

**multiset 容器和 set 容器唯一的差别在于，multiset 容器允许存储多个值相同的元素，而 set 容器中只能存储互不相同的元素。**

### <p id="C++STL无序容器">C++ STL无序容器</p>

和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，本教程将二者分开进行讲解，因为它们有本质上的不同：

- 关联式容器的底层实现采用的树存储结构，更确切的说是**红黑树**结构；
- 无序容器的底层实现采用的是**哈希表**的存储结构。

基于底层实现采用了不同的数据结构，因此和关联式容器相比，无序容器具有以下 2 个特点：

1. 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，
2. 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。

**C++ STL无序容器种类**

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/42.png)

unordered_map 容器模板的定义如下所示：

<pre>
template < class Key,                        //键值对中键的类型
           class T,                          //键值对中值的类型
           class Hash = hash< Key>,           //容器内部存储键值对所用的哈希函数
           class Pred = equal_to< Key>,       //判断各个键值对键相同的规则
           class Alloc = allocator< pair< const Key,T> >  // 指定分配器对象的类型
           > class unordered_map;
</pre>

unordered_map 类模板提供的所有常用的成员方法以及各自的功能。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/43.png)

**无序容器的底层实现机制**

C++ STL 标准库中，不仅是 unordered_map 容器，所有无序容器的底层实现都采用的是哈希表存储结构。更准确地说，是用“链地址法”（又称“开链法”）解决数据存储位置发生冲突的哈希表，整个存储结构如下图所示：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/44.png)

其中，Pi 表示存储的各个键值对。

可以看到，当使用无序容器存储键值对时，会先申请一整块连续的存储空间，但此空间并不用来直接存储键值对，而是存储各个链表的头指针，各键值对真正的存储位置是各个链表的节点。

注意，STL 标准库通常选用 vector 容器存储各个链表的头指针。

不仅如此，在 C++ STL 标准库中，将图 1 中的各个链表称为桶（bucket），每个桶都有自己的编号（从 0 开始）。当有新键值对存储到无序容器中时，整个存储过程分为如下几步：

- 将该键值对中键的值带入设计好的哈希函数，会得到一个哈希值（一个整数，用 H 表示）；
- 将 H 和无序容器拥有桶的数量 n 做整除运算（即 H % n），该结果即表示应将此键值对存储到的桶的编号；
- 建立一个新节点存储此键值对，同时将该节点链接到相应编号的桶上。

另外值得一提的是，哈希表存储结构还有一个重要的属性，称为负载因子（load factor）。该属性同样适用于无序容器，用于衡量容器存储键值对的空/满程序，即负载因子越大，意味着容器越满，即各链表中挂载着越多的键值对，这无疑会降低容器查找目标键值对的效率；反之，负载因子越小，容器肯定越空，但并不一定各个链表中挂载的键值对就越少。

举个例子，如果设计的哈希函数不合理，使得各个键值对的键带入该函数得到的哈希值始终相同（所有键值对始终存储在同一链表上）。这种情况下，即便增加桶数是的负载因子减小，该容器的查找效率依旧很差。

无序容器中，负载因子的计算方法为：

<pre>负载因子 = 容器存储的总键值对 / 桶数</pre>

默认情况下，无序容器的最大负载因子为 1.0。如果操作无序容器过程中，使得最大复杂因子超过了默认值，则容器会自动增加桶数，并重新进行哈希，以此来减小负载因子的值。需要注意的是，此过程会导致容器迭代器失效，但指向单个键值对的引用或者指针仍然有效。

**unordered\_map迭代器的用法**

C++ STL 标准库中，unordered\_map 容器迭代器的类型为前向迭代器（又称正向迭代器）。这意味着，假设 p 是一个前向迭代器，则其只能进行 *p、p++、++p 操作，且 2 个前向迭代器之间只能用 == 和 != 运算符做比较。

在 unordered_map 容器模板中，提供了下表所示的成员方法，可用来获取指向指定位置的前向迭代器。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/45.png)

**STL unordered_map获取元素的4种方式**

- unordered\_map容器类模板中，实现了对[]运算符的重载，直接用普通下标访问数组中的元素（如果没有相应元素，会添加以该下标为键的键值对）。
- unordered\_map类模板中，还提供at()成员方法，at()也需要根据指定的键，才能从容器中找到该键对应的值，不同的是，该方法查找失败时，不会添加新的键值对，而是直接抛出out\_of\_range异常。
- unordered_map模板还提供了find()成员方法。与其他两种方法不同的是，find()方法成功找到以指定元素为键的键值对时，返回的迭代器就指向该键值对。查找失败后，返回指向最后一个键值对的迭代器（与end()方法一致）。
- 借助begin()/end()迭代器，来遍历整个容器中键值来找目标键值对。

**容器选择**

要想选出最适合的容器。要考虑多种因素：

- 是否需要在指定位置插入元素，如果是只能选择序列式容器。
- 是否对容器中个元素的存储位置有要求，如果没有可以选择哈希容器，反之要避免使用哈希容器。
- 是否需要使用指定类型的迭代器，如果必须随机访问，只能选择array，vector，deque，如果必须双向迭代器，则可以考虑list序列容器以及所有的关联式容器，如果必须是前向迭代器，则可以考虑forward_list和所有的哈希容器。
- 当发生元素插入或删除操作时，是否要避免移动容器中其他元素？如果要，则要避开使用vector，array，deque。
- 容器中查找元素的效率是否为关键因素，如果是，则优先考虑哈希容器。

### <p id="STL线程安全">vector, map是不是线程安全，如何实现线程安全。</p>

STL语义上不提供任何强度的线程安全保障。对于vector，即使写方式单线程写入，但是并发读的时候，由于潜在的内存重新申请和对象复制的问题，仍然会导致读方迭代器失效。如果是多个写方，并发的push_back()，也会导致core dump。

**解决方法**

- 加锁是一种解决方法，对于读多写少的场景可以用读写锁（也叫共享独占锁）。C++17引入了std::shared_mutex。
- 通过固定的vector大小，避免动态扩容（无push_back)来做到lock-free。在并发读写之前（初始化时）给vector设置好大小（使用resize()函数，先分配好空间，而不是用reserve()函数），然后给元素类加上成员变量标记当前的读写状态。
- 对于map/unordered_map，并发的插入都会引发core dump。如果全量的key在并发之前就能拿到，提前进行insert。并发环境中如果只是修改同一个key的value，并不会造成core dump，但是会出现value覆盖，还是需要进行加锁操作。
## <p id="C++构造函数/析构函数">C++ 构造函数/析构函数</p>

**为什么引入构造函数与析构函数**

类的数据成员不能在类的声明时候初始化，为了解决这个问题，使用构造函数来处理对象的初始化。构造函数是一种特殊的成员函数，与其他函数不同，不需要用户调用（也可以显式调用），创造对象时自动调用。析构函数是对象不再使用的时候，需要清理资源的时候调用。

### <p id="构造函数与析构函数">构造函数与析构函数</p>

**构造函数**

构造函数的名称与类名完全相同，不会返回任何类型，也不会返回void。默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数，创建对象时就会给对象赋初始值。构造函数也可以使用初始化列表来初始化字段，可以被重载。

<pre>
C::C(double a, double b, double c):X(a),Y(b),Z(c) {
	......
}
</pre>

**构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。**

一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。

最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。

例如以下写法都是正确的:

<pre>
Student *pstu = new Student();
Student *pstu = new Student;
</pre>

**析构函数**

析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行，析构函数名称与类名完全相同，只是在前面增加（~）作为前缀，不会返回任何值，也不能带有任何参数，**不能被重载**，析构函数有助于在跳出程序（关闭文件，释放内存等）前释放资源。

### <p id="构造函数和析构函数能否为虚函数">构造函数和析构函数能否为虚函数</p>

**构造函数不能为虚函数，而析构函数多半为虚函数。**

虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的vptr来指向，该指针存放在对象的内部空间中，需要调用构造函数来完成初始化。如果构造函数是虚函数，那么调用构造函数的时候需要去找vptr，但此时vptr还没有初始化。

**C++类有继承的时候，析构函数必须为虚函数。**不然会存在内存泄露的情况。将可能被继承的父类的析构函数设置为虚函数，使用基类指针指向子类对象，释放基类指针可以释放掉子类空间，防止内存泄露。

例如：
<pre>
SubClass* pObj = new SubClass();
delete pObj;
</pre>
此时不管析构函数是否为虚函数(是否添加virtual关键字)，delete时基类和子类都会被释放掉。

但是如果是这样：
<pre>
BaseClass* pObj = new SubClass();
delete pObj;
</pre>

- 若析构函数是虚函数(含有virtual关键字)，delete时基类和子类都会被释放掉。
- 若析构函数不是虚函数，delete时只会释放基类，并不会释放子类。

**C++默认的析构函数不是虚函数，因为虚函数需要额外的虚函数表和虚函数表指针。占用额外的内存，降低效率，而且C++默认提供的类不会被继承。**

### <p id="构造函数和析构函数能否抛出异常">构造函数和析构函数能否抛出异常</p>

构造函数可以抛出异常，但是要额外注意**资源泄露**，构造函数抛出异常，会导致析构函数不能被调用，但对象本身已申请到的内存资源会被系统释放掉（已申请到资源的内部成员变量会被系统依次逆序调用其析构函数），但是因为析构函数不能被调用，还是可能会造成内存泄露或者系统资源未被释放。所以如果要在构造函数中抛出异常，要格外注意资源的释放。

析构函数不能抛出异常。析构函数抛出异常会导致程序过早的结束或者出现不明确的行为，如果一个操作可能出现异常，class应该提供一个普通函数来执行该操作，给客户一个处理错误的机会。

### <p id="构造函数/拷贝构造函数和赋值函数的区别和实现">构造函数/拷贝构造函数和赋值函数的区别和实现</p>

**C++构造函数**是一种特殊的类成员函数，当创建一个类的对象时，他被调用来对类的数据成员进行初始化和分配内存。

**拷贝构造函数**是C++独有的，他是一种特殊的构造函数，用基于同一个类的一个对象构造和初始化另一个对象，当没有重载拷贝构造函数时，通过默认拷贝构造函数来创建一个对象。
<pre>
class Father {
	public:
		Father(){
			cout<< "I created Father"<< endl;
			count = 1;
		}
		virtual ~ Father(){
			cout<< "I destoryed Father"<< endl;
		}
		Father& operator=(const Father& other) {
			count = 3;
		}
		void printF() {
			cout<< "count: "<< count<< endl;
		}
		int count;
};
class Child:public Father {
	public:
		Child() {
			cout<< "I created a Child"<< endl;
			cout<< count<< endl;
		}
		~ Child() {
			cout<< "I destoryed a Child"<< endl;
		}
	private:
		int count2;
};
</pre>
<pre>
Father f;
Father f2(f);
Father f3 = f;
</pre>
运行结果：
<pre>
I created Father;
I destoryed Father;
I destoryed Father;
I destoryed Father;
</pre>
上面结果所示，只调用了一次默认构造函数构造f，其余都没有调用构造函数，但是销毁时都会调用相应的析构函数。
以上方式都是通过拷贝构造函数来创建对象b（f2，f3），这里b都是不存在的，通过a对象来进行构造和初始化，而且可以看到这种构造方式是对a的一种**浅拷贝。**

<font color=red>注意，如果是存在指针类型，需要重载拷贝构造函数，因为默认拷贝构造函数为浅拷贝，如果不进行重载，新旧对象共享内存，这样析构函数会释放同一块内存，造成错误。</font>

**C++拷贝构造函数被调用的情况：**

1. 一个对象以值传递的方式传入函数体。
2. 一个对象以值传递的方式从函数返回。
3. 一个对象需要通过另一个对象进行初始化。

如果用户没有自定义拷贝构造函数，并且在代码中使用到了拷贝构造函数，编译器就会生成默认的拷贝构造函数，但如果用户定义了拷贝构造函数，编译器就不再生成。

如果用户定义了一个构造函数，但是不是拷贝构造函数，而此时代码中又用到了拷贝构造函数，那编译器也会生成默认的拷贝构造函数。

**注意拷贝构造函数传入的参数一定是引用，如果是传值会无穷递归调用拷贝构造函数。**

**深拷贝：**在复制一个对象的时候，创建了一个新的外部对象进行独立的复制。

**浅拷贝：**如果复制的对象引用了一个外部内容（例如分配在堆上的数据），那么在复制这个对象的时候，让新旧两个对象指向同一个外部内容，也就是浅拷贝。（指针虽然复制了，但是所指向的空间并没有被复制，是由两个对象共用）。

**赋值函数：**当一个类的对象向该类的另一个对象赋值时，就会用到该类的赋值函数。当没有重载赋值函数（赋值运算符）时，通过默认赋值函数来进行赋值操作。

**拷贝构造函数和赋值函数的区别：**

1. 拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区域，而赋值函数是对于一个已经被初始化的对象来进行赋值操作。
2. 一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：一是复制指针对象，另一种是引用指针对象。拷贝构造函数大多数是前者，而赋值函数是后者。
3. 拷贝构造函数首先是一个构造函数，它调用的时候是通过参数的对象初始化产生一个对象。而赋值函数则是把一个新的对象赋值给一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检查一下两个对象是不是同一个对象，如果是不做任何操作。

**如果不想写拷贝构造函数和赋值函数，又不允许别人使用编译器生成缺省函数，可以将拷贝构造函数和赋值函数声明为私有，或者声明后面加delete。**

### <p id="C++函数初始化方式">C++ 函数初始化方式</p>

函数初始化方式可以分为以下几种：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/46.png)

<pre>
public:
	ClassTest()//定义默认构造函数
	{
		c[0] = '\0';
		cout << "ClassTest()" << endl;
	}
	ClassTest& operator=(const ClassTest &ct) //重载赋值操作符
	{
		strcpy_s(c, ct.c);
		cout << "ClassTest& operator=(const ClassTest &ct)" << endl;
		return *this;
	}
	ClassTest(const char *pc)
	{
		strcpy_s(c, pc);
		cout << "ClassTest (const char *pc)" << endl;
	}  
	ClassTest(const ClassTest& ct)//复制构造函数
	{
		strcpy_s(c, ct.c);
		cout << "ClassTest(const ClassTest& ct)" << endl;
	}
private:
	char c[256];
};
 
ClassTest func(ClassTest temp){
	return temp;
}
 
int main(){
	cout << "ct1: ";
	ClassTest ct1("ab");//直接初始化  
	cout << "ct2: ";
	ClassTest ct2 = "ab";//复制初始化  
	/*输出说明：
	ClassTest ct2 = "ab";
	它本来是要这样来构造对象的：
	首先调用构造函数ClassTest(const char *pc)函数创建
	一个临时对象，然后调用复制构造函数，把这个临时对象作
	为参数，构造对象ct2。然而编译也发现，复制构造函数是
	公有的，即你明确地告诉了编译器，你允许对象之间的复制，
	而且此时它发现可以通过直接调用重载的构造函数
	ClassTest(const char *pc)来直接初始化对象，而达到
	相同的效果，所以就把这条语句优化为
	ClassTest ct2（"ab"）。
	*/
	cout << "ct3: ";
	ClassTest ct3 = ct1;//复制初始化  
	cout << "ct4: ";
	ClassTest ct4(ct1);//直接初始化  
	cout << "ct5: ";
	ClassTest ct5 = ClassTest();//复制初始化 
	cout << "ct6: ";
	ClassTest ct6;//复制初始化
	ct6 = "caoyan is a good boy!";
	cout << "ct7: ";
	ClassTest ct7;
	ct7 = func(ct6);
	return 0;
}
</pre>
运行结果
<pre>
ct1: ClassTest (const char *pc)
ct2: ClassTest (const char *pc)
ct3: ClassTest(const ClassTest& ct)
ct4: ClassTest(const ClassTest& ct)
ct5: ClassTest()
ct6: ClassTest()
ClassTest (const char *pc)
ClassTest& operator=(const ClassTest &ct)
ct7: ClassTest()
ClassTest(const ClassTest& ct)
ClassTest(const ClassTest& ct)
ClassTest& operator=(const ClassTest &ct)
</pre>

对于ct1，是属于带参数的初始化，对于ct2，原本应该先用带参数的初始化初始化“ab”，然后重载运算符赋值，但是编译器进行了优化，优化成了ct1.对于ct3，ct4是使用拷贝构造函数的方式进行初始化，ct5，ct6直接调用没有参数的构造函数，然后ct6中新字符串先是通过带参数法构造字符串，然后重载运算符赋值。

ct7首先调用没有参数的构造函数，在调用函数时，首先调用拷贝构造函数给temp传值，然后返回一个classTest对象，编辑器会将temp对象拷贝到func函数的上一级栈帧中，它的上一级栈帧是main函数的栈帧，当函数返回时，参数出栈，temp超出作用返回，内存空间会被收回，但是他的值拷贝到main栈帧的一个预留空间中，所以temp到预留空间的拷贝也是调用拷贝构造函数，最后一步赋值操作重载运算符。

### <p id="C++初始化列表">C++初始化列表</p>

与其他函数不同，构造函数除了拥有名字，参数列表和函数体之外，还有初始化列表，初始化列表以冒号开头，后跟一系列以逗号分隔的初始化字段。

<pre>
class foo {
	public:
		foo(string _name, int _id): name(_name), id(_id) {}; // 初始化列表
	private:
		string name;
		int id;
}
</pre>

**使用初始化列表原因**

使用初始化列表主要是考虑性能方面的原因。对于内置类型，如int，float等，使用初始化列表和构造函数体内初始化差别不是很大，但是对于类类型来说，最好是使用初始化列表，**使用初始化列表少了一次调用默认构造函数的过程（使用拷贝构造函数），对于数据密集型类来说，是非常高效的。**

必须使用初始化列表的情况:

- 常量成员，常量只能初始化不能赋值，所以必须放在初始化列表里面。
- 引用类型，引用必须在定义的时候初始化，并且不能被重新赋值，所以要放在初始化列表中。
- 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。
- **初始化 const 成员变量的唯一方法就是使用初始化列表。**

**成员变量的顺序**

成员变量是按照他们在**类中出现的顺序进行初始化**的，而不是按照他们在初始化列表中出现的顺序初始化。

<pre>
class foo {
	public:
		foo(int x): i(x), j(i)  {
			cout<< "j: "<< j<< " i: "<< i<< endl;
		}; 
	private:
		int i;
		int j;
};
</pre>
运行结果：
<pre>j: 1 i: 1</pre>
如果我们调换初始化顺序：
<pre>
class foo {
	public:
		foo(int x): j(x), i(j) {
			cout<< "j: "<< j<< " i: "<< i<< endl;
		}; 
	private:
		int i;
		int j;
};
</pre>
运行结果：
<pre>j: 1 i: 0</pre>

可以看到虽然两者都可以编译运行，但是后者i并没有被初始化成功，而是默认初始化成了0。
## <p id="C++友元函数">C++ 友元函数</p>
在 C++ 中，一个类中可以有 public、protected、private 三种属性的成员，通过对象可以访问 public 成员，只有本类中的函数可以访问本类的 private 成员。现在，我们来介绍一种例外情况——友元（friend）。**借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。**在 C++ 中，这种友好关系可以用 friend 关键字指明，中文多译为“友元”，借助友元可以访问与其有好友关系的类中的私有成员。如果你对“友元”这个名词不习惯，可以按原文 friend 理解为朋友。
### 友元函数
在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。

友元函数可以访问当前类中的所有成员，包括 public、protected、private 属性的。

**1) 将非成员函数声明为友元函数。**

请大家直接看下面的例子：
<pre>
class Student{
public:
    Student(char *name, int age, float score);
public:
    friend void show(Student *pstu);  //将show()声明为友元函数
private:
    char *m_name;
    int m_age;
    float m_score;
};
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
//非成员函数
void show(Student *pstu){
    cout<< pstu->m_name<< "的年龄是 "<< pstu->m_age<< "，成绩是 "<< pstu->m_score<< endl;
}
int main(){
    Student stu("小明", 15, 90.6);
    show(&stu);  //调用友元函数
    Student *pstu = new Student("李磊", 16, 80.5);
    show(pstu);  //调用友元函数
    return 0;
}
</pre>
show() 是一个全局范围内的非成员函数，它不属于任何类，它的作用是输出学生的信息。m_name、m_age、m_score 是 Student 类的 private 成员，原则上不能通过对象访问，但在 show() 函数中又必须使用这些 private 成员，所以将 show() 声明为 Student 类的友元函数。读者可以亲自测试一下，将上面程序中的第 8 行删去，观察编译器的报错信息。

**注意，友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。下面的写法是错误的：**
<pre>
void show(){
    cout<< m_name<< "的年龄是 "<< m_age<< "，成绩是 "<< m_score<< endl;
}
</pre>
成员函数在调用时会隐式地增加 this 指针，指向调用它的对象，从而使用该对象的成员；而 show() 是非成员函数，没有 this 指针，编译器不知道使用哪个对象的成员，要想明确这一点，就必须通过参数传递对象（可以直接传递对象，也可以传递对象指针或对象引用），并在访问成员时指明对象。
关于友元，有两点需要说明：

- 友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。
- 友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。

**2) 将其他类的成员函数声明为友元函数**

friend 函数不仅可以是全局函数（非成员函数），还可以是另外一个类的成员函数。请看下面的例子：
<pre>
class Address;  //提前声明Address类
//声明Student类
class Student{
public:
    Student(char *name, int age, float score);
public:
    void show(Address *addr);
private:
    char *m_name;
    int m_age;
    float m_score;
};
//声明Address类
class Address{
private:
    char *m_province;  //省份
    char *m_city;  //城市
    char *m_district;  //区（市区）
public:
    Address(char *province, char *city, char *district);
    //将Student类中的成员函数show()声明为友元函数
    friend void Student::show(Address *addr);
};
//实现Student类
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){}
void Student::show(Address *addr){
    cout<< m_name<< "的年龄是 "<< m_age<< "，成绩是 "<< m_score<<endl;
    cout<< "家庭住址："<< addr->m_province;
	cout<< "省"<< addr->m_city<< "市";
	cout<< addr->m_district<< "区"<< endl;
}
//实现Address类
Address::Address(char *province, char *city, char *district){
    m_province = province;
    m_city = city;
    m_district = district;
}
int main(){
    Student stu("小明", 16, 95.5f);
    Address addr("陕西", "西安", "雁塔");
    stu.show(&addr);
   
    Student *pstu = new Student("李磊", 16, 80.5);
    Address *paddr = new Address("河北", "衡水", "桃城");
    pstu -> show(paddr);
    return 0;
}
</pre>
输出结果
<pre>
小明的年龄是 16，成绩是 95.5
家庭住址：陕西省西安市雁塔区
李磊的年龄是 16，成绩是 80.5
家庭住址：河北省衡水市桃城区
</pre>
本例定义了两个类 Student 和 Address，程序第 27 行将 Student 类的成员函数 show() 声明为 Address 类的友元函数，由此，show() 就可以访问 Address 类的 private 成员变量了。

几点注意：

1. 程序第 4 行对 Address 类进行了提前声明，是因为在 Address 类定义之前、在 Student 类中使用到了它，如果不提前声明，编译器会报错，提示'Address' has not been declared。类的提前声明和函数的提前声明是一个道理。

2. 程序将 Student 类的声明和实现分开了，而将 Address 类的声明放在了中间，这是因为编译器从上到下编译代码，show() 函数体中用到了 Address 的成员 province、city、district，如果提前不知道 Address 的具体声明内容，就不能确定 Address 是否拥有该成员（类的声明中指明了类有哪些成员）。

	这里简单介绍一下类的提前声明。一般情况下，类必须在正式声明之后才能使用；但是某些情况下（如上例所示），只要做好提前声明，也可以先使用。
	
	但是应当注意，类的提前声明的使用范围是有限的，只有在正式声明一个类以后才能用它去创建对象。如果在上面程序的第1行之后增加如下所示的一条语句，编译器就会报错：
	<pre>
	Address addr;  //企图使用不完整的类来创建对象
	</pre>
	因为创建对象时要为对象分配内存，在正式声明类之前，编译器无法确定应该为对象分配多大的内存。编译器只有在“见到”类的正式声明后（其实是见到成员变量），才能确定应该为对象预留多大的内存。在对一个类作了提前声明后，可以用该类的名字去定义指向该类型对象的指针变量（本例就定义了 Address 类的指针变量）或引用变量（后续会介绍引用），因为指针变量和引用变量本身的大小是固定的，与它所指向的数据的大小无关。

3. 一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。

关于友元，有两点需要说明：

- 友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。
- 友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。
## <p id="C++11">C++11新特性</p>

### <p id="auto类型推导">auto类型推导</p>

使用了 auto 关键字以后，编译器会在编译期间自动推导出变量的类型。

auto 关键字基本的使用语法如下：
<pre>
auto name = value;
</pre>
name 是变量的名字，value 是变量的初始值。

注意：auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。

auto 类型推导的简单例子：
<pre>
auto n = 10;
auto f = 12.8;
auto p = &n;
auto url = "http://c.biancheng.net/cplus/";
</pre>
下面解释一下：

- 第 1 行中，10 是一个整数，默认是 int 类型，所以推导出变量 n 的类型是 int。
- 第 2 行中，12.8 是一个小数，默认是 double 类型，所以推导出变量 f 的类型是 double。
- 第 3 行中，&n 的结果是一个 int* 类型的指针，所以推导出变量 p 的类型是 int*。
- 第 4 行中，由双引号""包围起来的字符串是 const char* 类型，所以推导出变量 url 的类型是 const char*，也即一个常量指针。

auto 除了可以独立使用，还可以和某些具体类型混合使用，这样 auto 表示的就是“半个”类型，而不是完整的类型。请看下面的代码：
<pre>
int  x = 0;
auto *p1 = &x;   //p1 为 int *，auto 推导为 int
auto  p2 = &x;   //p2 为 int*，auto 推导为 int*
auto &r1  = x;   //r1 为 int&，auto 推导为 int
auto r2 = r1;    //r2 为  int，auto 推导为 int
</pre>
下面我们来解释一下：

- 第 2 行代码中，p1 为 int* 类型，也即 auto * 为 int *，所以 auto 被推导成了 int 类型。
- 第 3 行代码中，auto 被推导为 int* 类型，前边的例子也已经演示过了。
- 第 4 行代码中，r1 为 int & 类型，auto 被推导为 int 类型。
- 第 5 行代码是需要重点说明的，r1 本来是 int& 类型，但是 auto 却被推导为 int 类型，这表明当=右边的表达式是一个引用类型时，auto 会把引用抛弃，直接推导出它的原始类型。

接下来，我们再来看一下 auto 和 const 的结合：
<pre>
int  x = 0;
const  auto n = x;  //n 为 const int ，auto 被推导为 int
auto f = n;      //f 为 const int，auto 被推导为 int（const 属性被抛弃）
const auto &r1 = x;  //r1 为 const int& 类型，auto 被推导为 int
auto &r2 = r1;  //r1 为 const int& 类型，auto 被推导为 const int 类型
</pre>
下面我们来解释一下：

- 第 2 行代码中，n 为 const int，auto 被推导为 int。
- 第 3 行代码中，n 为 const int 类型，但是 auto 却被推导为 int 类型，这说明当=右边的表达式带有 const 属性时， auto 不会使用 const 属性，而是直接推导出 non-const 类型。
- 第 4 行代码中，auto 被推导为 int 类型，这个很容易理解，不再赘述。
- 第 5 行代码中，r1 是 const int & 类型，auto 也被推导为 const int 类型，这说明当 const 和引用结合时，auto 的推导将保留表达式的 const 类型。

最后我们来简单总结一下 auto 与 const 结合的用法：

- 当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；
- 当类型为引用时，auto 的推导结果将保留表达式的 const 属性。

**auto 的限制**

1. auto 不能在函数的参数中使用。这个应该很容易理解，我们在定义函数的时候只是对参数进行了声明，指明了参数的类型，但并没有给它赋值，只有在实际调用函数的时候才会给参数赋值；而 auto 要求必须对变量进行初始化，所以这是矛盾的。
2. auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中。
3. auto 关键字不能定义数组，比如下面的例子就是错误的：
	<pre>
	char url[] = "http://c.biancheng.net/";
	auto  str[] = url;  //arr 为数组，所以不能使用 auto
	</pre>
4.  auto 不能作用于模板参数，请看下面的例子
	<pre>
	template < typename T>
	class A{
	    //TODO:
	};
	int  main(){
	    A< int> C1;
	    A< auto> C2 = C1;  //错误
	    return 0;
	}
	</pre>

### <p id="decltype类型推导">decltype类型推导</p>

decltype 是“declare type”的缩写，译为“声明类型”。

decltype的使用方式：
<pre>
decltype(exp) varname = value;
</pre>
其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。

auto 根据=右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟=右边的 value 没有关系。

**exp 注意事项**
原则上讲，exp 就是一个普通的表达式，它可以是任意复杂的形式，但是我们必须要保证 exp 的结果是有类型的，不能是 void；例如，当 exp 调用一个返回值类型为 void 的函数时，exp 的结果也是 void 类型，此时就会导致编译错误。

<pre>
int a = 0;
decltype(a) b = 1;  //b 被推导成了 int
decltype(10.8) x = 5.5;  //x 被推导成了 double
decltype(x + 100) y;  //y 被推导成了 double
</pre>
可以看到，decltype 能够根据变量、字面量、带有运算符的表达式推导出变量的类型。读者请留意第 4 行，y 没有被初始化。

**decltype 推导规则**

上面的例子让我们初步感受了一下 decltype 的用法，但你不要认为 decltype 就这么简单，它的玩法实际上可以非常复杂。当程序员使用 decltype(exp) 获取类型时，编译器将根据以下三条规则得出结果：

- 如果 exp 是一个不被括号( )包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。
- 如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。
- 如果 exp 是一个左值，或者被括号( )包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&。

举例如下：

**exp 是一个普通表达式:**
<pre>
class Student{
public:
    static int total;
    string name;
    int age;
    float scores;
};
int Student::total = 0;
int  main(){
    int n = 0;
    const int &r = n;
    Student stu;
    decltype(n) a = n;  //n 为 int 类型，a 被推导为 int 类型
    decltype(r) b = n;     //r 为 const int& 类型, b 被推导为 const int& 类型
    decltype(Student::total) c = 0;  //total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型
    decltype(stu.name) url = "http://c.biancheng.net/cplus/";  //total 为类 Student 的一个 string 类型
	的成员变量， url 被推导为 string 类型
    return 0;
}
</pre>

**exp 为函数调用：**
<pre>
//函数声明
int& func_int_r(int, char);  //返回值为 int&
int&& func_int_rr(void);  //返回值为 int&&
int func_int(double);  //返回值为 int
const int& fun_cint_r(int, int, int);  //返回值为 const int&
const int&& func_cint_rr(void);  //返回值为 const int&&
//decltype类型推导
int n = 100;
decltype(func_int_r(100, 'A')) a = n;  //a 的类型为 int&
decltype(func_int_rr()) b = 0;  //b 的类型为 int&&
decltype(func_int(10.5)) c = 0;   //c 的类型为 int
decltype(fun_cint_r(1,2,3))  x = n;    //x 的类型为 const int &
decltype(func_cint_rr()) y = 0;  // y 的类型为 const int&&
</pre>

**exp 是左值，或者被( )包围：**
<pre>
class Base{
public:
    int x;
};
int main(){
    const Base obj;
    //带有括号的表达式
    decltype(obj.x) a = 0;  //obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int
    decltype((obj.x)) b = a;  //obj.x 带有括号，符合推导规则三，b 的类型为 int&。
    //加法表达式
    int n = 0, m = 0;
    decltype(n + m) c = 0;  //n+m 得到一个右值，符合推导规则一，所以推导结果为 int
    decltype(n = n + m) d = c;  //n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&
    return 0;
</pre>

**auto和decltype的区别**

**1. 语法格式的区别**:

auto 和 decltype 都会自动推导出变量 varname 的类型,auto 根据=右边的初始值 value 推导出变量的类型，decltype 根据 exp 表达式推导出变量的类型，跟=右边的 value 没有关系。

auto 要求变量必须初始化，也就是在定义变量的同时必须给它赋值；而 decltype 不要求，初始化与否都不影响变量的类型。

auto 将变量的类型和初始值绑定在一起，而 decltype 将变量的类型和初始值分开；虽然 auto 的书写更加简洁，但 decltype 的使用更加灵活。

**2. 对 cv 限定符的处理**：

cv 限定符是 const 和 volatile 关键字的统称：

- const 关键字用来表示数据是只读的，也就是不能被修改；
- volatile 和 const 是相反的，它用来表示数据是可变的、易变的，目的是不让 CPU 将数据缓存到寄存器，而是从原始的内存中读取。

在推导变量类型时，auto 和 decltype 对 cv 限制符的处理是不一样的。decltype 会保留 cv 限定符，而 auto 有可能会去掉 cv 限定符。

以下是 auto 关键字对 cv 限定符的推导规则：

- 如果表达式的类型不是指针或者引用，auto 会把 cv 限定符直接抛弃，推导成 non-const 或者 non-volatile 类型。
- 如果表达式的类型是指针或者引用，auto 将保留 cv 限定符。

**3. 对引用的处理**

当表达式的类型为引用时，auto 和 decltype 的推导规则也不一样；decltype 会保留引用类型，而 auto 会抛弃引用类型，直接推导出它的原始类型。

### <p id="lambda匿名函数">lambda匿名函数</p>

定义一个lambda匿名函数格式如下：
<pre>
[外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型
{
   函数体;
};
</pre>
**[外部变量方位方式说明符]**:[ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。
所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。

**(参数)**:
和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略。

**mutable**：
此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。

**注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；**

**noexcept/throw()**：可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。

值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败。

**-> 返回值类型**：指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略-> 返回值类型。

**函数体**：和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。

需要注意的是，外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。

**lambda匿名函数中的[外部变量]**

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/47.png)

注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。

**lambda匿名函数使用例子：**

lambda 匿名函数的定义和使用。
<pre>
int main()
{
    int num[4] = {4, 2, 3, 1};
    //对 a 数组中的元素进行排序
    sort(num, num+4, [=](int x, int y) -> bool{ return x < y; } );
    for(int n : num){
        cout << n << " ";
    }
    return 0;
}
</pre>
程序执行结果为：
<pre>1 2 3 4</pre>

值传递和引用传递
<pre>
//全局变量
int all_num = 0;
int main()
{
    //局部变量
    int num_1 = 1;
    int num_2 = 2;
    int num_3 = 3;
    cout << "lambda1:\n";
    auto lambda1 = [=]{
        //全局变量可以访问甚至修改
        all_num = 10;
        //函数体内只能使用外部变量，而无法对它们进行修改
        cout << num_1 << " "
             << num_2 << " "
             << num_3 << endl;
    };
    lambda1();
    cout << all_num << endl;
    cout << "lambda2:\n";
    auto lambda2 = [&]{
        all_num = 100; 
        num_1 = 10;
        num_2 = 20;
        num_3 = 30;
        cout << num_1 << " "
             << num_2 << " "
             << num_3 << endl;
    };
    lambda2();
    cout << all_num << endl;
    return 0;
}
</pre>
执行结果：
<pre>
lambda1:
1 2 3
10
lambda2:
10 20 30
100
</pre>

其中，lambda1 匿名函数是以 [=] 值传递的方式导入的局部变量，这意味着默认情况下，此函数内部无法修改这 3 个局部变量的值，但全局变量 all_num 除外。相对地，lambda2 匿名函数以 [&] 引用传递的方式导入这 3 个局部变量，因此在该函数的内部不就可以访问这 3 个局部变量，还可以任意修改它们。同样，也可以访问甚至修改全局变量。

当然，如果我们想在 lambda1 匿名函数的基础上修改外部变量的值，可以借助 mutable 关键字。
<pre>
auto lambda1 = [=]() mutable{
    num_1 = 10;
    num_2 = 20;
    num_3 = 30;
    //函数体内只能使用外部变量，而无法对它们进行修改
    cout << num_1 << " "
         << num_2 << " "
         << num_3 << endl;
};
</pre>

### <p id="右值引用">右值引用</p>

右值引用可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。

通常情况下，判断某个表达式是左值还是右值，最常用的有以下 2 种方法。

1) 可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子：
<pre>
int a = 5;
5 = a; //错误，5 不能为左值
</pre>
其中，变量 a 就是一个左值，而字面量 5 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用，例如：
<pre>
int b = 10; // b 是一个左值
a = b; // a、b 都是左值，只不过将 b 可以当做右值使用
</pre>
2) 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。

以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &a 和 &b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。 

其实 C++98/03 标准中就有引用，使用 "&" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：
<pre>
int num = 10;
int &b = num; //正确
int &c = 10; //错误
</pre>
编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。

注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：
<pre>
int num = 10;
const int &b = num;
const int &c = 10;
</pre>

我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。

为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 "&&" 表示。

需要注意的，和声明左值引用一样，**右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，**比如：
<pre>
int num = 10;
//int && a = num;  //右值引用不能初始化为左值
int && a = 10;
</pre>

和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：
<pre>
int && a = 10;
a = 100;
cout << a << endl; //输出100
</pre>

右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/48.png)

### <p id="移动构造函数">移动构造函数</p>

在 C++ 11 标准之前（C++ 98/03 标准中），如果想用其它对象初始化一个同类的新对象，只能借助类中的复制（拷贝）构造函数。**需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员。**

<pre>
class demo{
public:
   demo():num(new int(0)){
      cout<< "construct!"<< endl;
   }
   //拷贝构造函数
   demo(const demo &d):num(new int(*d.num)){
      cout<< "copy construct!"<< endl;
   }
   ~demo(){
      cout<< "class destruct!"<< endl;
   }
private:
   int *num;
};
demo get_demo(){
    return demo();
}
int main(){
    demo a = get_demo();
    return 0;
}
</pre>
如上所示，我们为 demo 类自定义了一个拷贝构造函数。该函数在拷贝 d.num 指针成员时，必须采用深拷贝的方式，即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。否则一旦多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次，这是不允许的。

可以看到，程序中定义了一个可返回 demo 对象的 get\_demo() 函数，用于在 main() 主函数中初始化 a 对象，其整个初始化的流程包含以下几个阶段：

1. 执行 get\_demo() 函数内部的 demo() 语句，即调用 demo 类的默认构造函数生成一个匿名对象；
2. 执行 return demo() 语句，会调用拷贝构造函数复制一份之前生成的匿名对象，并将其作为 get\_demo() 函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；
3. 执行 a = get\_demo() 语句，再调用一次拷贝构造函数，将之前拷贝得到的临时对象复制给 a（此行代码执行完毕，get\_demo() 函数返回的对象会被析构）；
4. 程序执行结束前，会自行调用 demo 类的析构函数销毁 a。

注意，目前多数编译器都会对程序中发生的拷贝操作进行优化，因此如果我们使用 VS 2017、codeblocks 等这些编译器运行此程序时，看到的往往是优化后的输出结果：
<pre>
construct!
class destruct!
</pre>
而同样的程序，如果在 Linux 上使用g++ demo.cpp -fno-elide-constructors命令运行（其中 demo.cpp 是程序文件的名称），就可以看到完整的输出结果：
<pre>
construct!            <-- 执行 demo()
copy construct!       <-- 执行 return demo()
class destruct!       <-- 销毁 demo() 产生的匿名对象
copy construct!       <-- 执行 a = get_demo()
class destruct!       <-- 销毁 get_demo() 返回的临时对象
class destruct!       <-- 销毁 a
</pre>
如上所示，利用拷贝构造函数实现对 a 对象的初始化，底层实际上进行了 2 次拷贝（而且是深拷贝）操作。当然，对于仅申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么 2 次深拷贝操作势必会影响 a 对象初始化的执行效率。

为了解决拷贝构造函数的效率问题，C++11引入移动构造函数。

**C++移动构造函数（移动语义的具体实现）**

所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。

以前面程序中的 demo 类为例，该类的成员都包含一个整形的指针成员，其默认指向的是容纳一个整形变量的堆空间。当使用 get_demo() 函数返回的临时对象初始化 a 时，我们只需要将临时对象的 num 指针直接浅拷贝给 a.num，然后修改该临时对象中 num 指针的指向（通常另其指向 NULL），这样就完成了 a.num 的初始化。

事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。

<pre>
class demo{
public:
    demo():num(new int(0)){
        cout<< "construct!"<< endl;
    }
    demo(const demo &d):num(new int(*d.num)){
        cout<< "copy construct!"<< endl;
    }
    //添加移动构造函数
    demo(demo &&d):num(d.num){
        d.num = NULL;
        cout<< "move construct!"<< endl;
    }
    ~demo(){
        cout<< "class destruct!"<< endl;
    }
private:
    int *num;
};
demo get_demo(){
    return demo();
}
int main(){
    demo a = get_demo();
    return 0;
}
</pre>

可以看到，在之前 demo 类的基础上，我们又手动为其添加了一个构造函数。和其它构造函数不同，此构造函数使用右值引用形式的参数，又称为移动构造函数。并且在此构造函数中，num 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生。

在 Linux 系统中使用g++ demo.cpp -o demo.exe -std=c++0x -fno-elide-constructors命令执行此程序，输出结果为：
<pre>
construct!
move construct!
class destruct!
move construct!
class destruct!
class destruct!
</pre>
通过执行结果我们不难得知，当为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都转由移动构造函数完成。

我们知道，非 const 右值引用只能操作右值，程序执行结果中产生的临时对象（例如函数返回值、lambda 表达式等）既无名称也无法获取其存储地址，所以属于右值。**当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。**

在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。

**move函数**

移动构造函数的调用时机是：用同类的右值对象初始化新对象。那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，C++11 标准中已经给出了解决方案，即调用 move() 函数。

move 本意为 "移动"，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。
基于 move() 函数特殊的功能，其常用于实现移动语义。

move() 函数的用法也很简单，其语法格式如下：
<pre>
move( arg )
</pre>
其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。

### <p id="nullptr">nullptr</p>

实际开发中，避免产生“野指针”最有效的方法，就是定义指针的同时完成初始化操作，即使该指针的指向尚未明确，也要将其初始化为空指针。nullptr是nullptr_t类型的右值常量，专用于初始化空类型指针，nullptr仅是该类型的一个实例对象。C++中NULL定义为字面常量0，虽然能满足大部分场景，但是个别情况下会与预期不符。
## <p id="智能指针">C++11智能指针</p>

在实际开发C++过程中，会遭遇到程序运行中突然崩溃，程序运行所需要内存越来越多最终不得不重启。这些问题往往都是内存资源管理不当造成的，比如：

- 有的内存资源已经被释放，但是指向他的指针并没有改变指向（成为野指针），并且后续还在使用。
- 有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）。
- 没有及时释放不再使用的内存资源，导致内存泄露，程序占用的内存资源越来越多。

C++11新标准在废弃了auto\_ptr的同时，新加了unique\_ptr, shared\_ptr以及weak\_ptr三个智能指针来实现堆内存的自动回收。

C++智能指针底层是采用引用计数的方式实现的，简单的理解，智能指针在申请堆内存空间的同时，会为其配置一个整形值（初始值为1），每当有新对象使用此堆内存时，该整型值+1，反之，每当使用此堆内存的对象被释放时，该整型值减1。当堆空间对应的整型值为0时，即表明不再有对象使用它，该堆空间就会被释放掉。

### <p id="auto_ptr">auto_ptr</p>

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/49.png)

由new expression获取对象，在auto_ptr对象销毁时，他所管理的对象也会被自动delete掉。

**所有权转移：**不小心将其传递给另外的智能指针时，原先的指针就不再拥有该对象。在拷贝/赋值过程中，会直接剥夺指针对于原对象对内存的控制权，转交给新对象，然后将原对象指针设置为nullptr。

由于auto\_ptr存在的问题，目前C++17中已经被抛弃了。

### <p id="unique_ptr">unique_ptr</p>

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/50.png)

unique\_ptr是专属所有权，所以unique\_ptr管理的内存，只能被一个对象持有，不支持复制和赋值。

**移动语义：** unique\_ptr虽然禁止了拷贝语义，但是我们也需要能够转移所有权，于是提供了移动语义，即可以使用std::move()进行控制所有权转换。

每个 unique\_ptr 指针指向的堆内存空间的引用计数，都只能为 1，一旦该 unique\_ptr 指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。

unique\_ptr的创建方法：
<pre>
//创建空的unique_ptr
std::unique_ptr< int> p1();
std::unique_ptr< int> p2(nullptr);
//创建unique_ptr并且明确指向
std::unique_ptr< int> p3(new int);
</pre>
基于 unique\_ptr 类型指针不共享各自拥有的堆内存，因此 C++11 标准中的 unique\_ptr 模板类没有提供拷贝构造函数，只提供了移动构造函数。例如：
<pre>
std::unique_ptr< int> p4(new int);
std::unique_ptr< int> p5(p4);//错误，堆内存不共享
std::unique_ptr< int> p5(std::move(p4));//正确，调用移动构造函数
</pre>
值得一提的是，对于调用移动构造函数的 p4 和 p5 来说，p5 将获取 p4 所指堆空间的所有权，而 p4 将变成空指针（nullptr）。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/51.png)

### <p id="shared_ptr">shared_ptr</p>

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/52.png)

shared\_ptr通过一个引用计数共享一个对象。

shared\_ptr用于解决unique\_ptr在对象所有权的局限性，在使用引用计数的机制上提供了可以共享所有权的智能指针，当然这需要额外的开销。

当引用计数为0时，该对象没有被使用，可以进行析构。

和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。

shared\_ptr的创建
<pre>
//创建空的shared_ptr
std::shared_ptr< int> p1;             //不传入任何实参
std::shared_ptr< int> p2(nullptr);    //传入空指针 nullptr
//创建shared_ptr并且明确指向
std::shared_ptr< int> p3(new int(10));
//同时，C++11 标准中还提供了 std::make_shared< T> 模板函数，其可以用于初始化 shared_ptr 智能指针，例如：
std::shared_ptr< int> p3 = std::make_shared< int>(10);
</pre>
**要注意的是，空的shared\_ptr的引用计数是0。**
除此之外，shared\_ptr也有相应的拷贝构造函数以及移动构造函数：
<pre>
//调用拷贝构造函数
std::shared_ptr< int> p4(p3);//或者 std::shared_ptr< int> p4 = p3;
//调用移动构造函数
std::shared_ptr< int> p5(std::move(p4)); //或者 std::shared_ptr< int> p5 = std::move(p4);
</pre>
如上所示，p3 和 p4 都是 shared\_ptr 类型的智能指针，因此可以用 p3 来初始化 p4，由于 p3 是左值，因此会调用拷贝构造函数。需要注意的是，如果 p3 为空智能指针，则 p4 也为空智能指针，其引用计数初始值为 0；反之，则表明 p4 和 p3 指向同一块堆内存，同时该堆空间的引用计数会加 1。

而对于 std::move(p4) 来说，该函数会强制将 p4 转换成对应的右值，因此初始化 p5 调用的是移动构造函数。另外和调用拷贝构造函数不同，用 std::move(p4) 初始化 p5，会使得 p5 拥有了 p4 的堆内存，而 p4 则变成了空智能指针。

注意，同一个普通指针不能同时为多个shared_ptr赋值，否则会发生异常：
<pre>
int* ptr = new int;
std::shared_ptr< int> p1(ptr);
std::shared_ptr< int> p2(ptr);//错误
</pre>

shared\_ptr也提供了一些成员方法：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/55.png)

### <p id="weak_ptr">weak_ptr</p>

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/54.png)

C++11标准虽然将 weak\_ptr 定位为智能指针的一种，但该类型指针通常不单独使用（没有实际用处），只能和 shared\_ptr 类型指针搭配使用。甚至于，我们可以将 weak\_ptr 类型指针视为 shared\_ptr 指针的一种辅助工具，借助 weak\_ptr 类型指针， 我们可以获取 shared\_ptr 指针的一些状态信息，比如有多少指向相同的 shared\_ptr 指针、shared\_ptr 指针指向的堆内存是否已经被释放等等。

需要注意的是，当 weak\_ptr 类型指针的指向和某一 shared\_ptr 指针相同时，weak\_ptr 指针并不会使所指堆内存的引用计数加 1；同样，当 weak\_ptr 指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。也就是说，weak\_ptr 类型指针并不会影响所指堆内存空间的引用计数。当其观察的shared\_ptr被释放后，对应的weak\_ptr也会失效。

除此之外，weak\_ptr<T> 模板类中没有重载 * 和 -> 运算符，这也就意味着，**weak\_ptr 类型指针只能访问所指的堆内存，而无法修改它**。

weak\_ptr的创建
<pre>
//创建空的weak_ptr
std::weak_ptr< int> wp1;
//凭借已有的 weak_ptr 指针，可以创建一个新的 weak_ptr 指针
std::weak_ptr< int> wp2 (wp1);
</pre>
若 wp1 为空指针，则 wp2 也为空指针；反之，如果 wp1 指向某一 shared\_ptr 指针拥有的堆内存，则 wp2 也指向该块存储空间（可以访问，但无所有权）。

weak\_ptr 指针更常用于指向某一 shared\_ptr 指针拥有的堆内存，因为在构建 weak\_ptr 指针对象时，可以利用已有的 shared\_ptr 指针为其初始化。例如：
<pre>
std::shared_ptr< int> sp (new int);
std::weak_ptr< int> wp3 (sp);
</pre>
由此，wp3 指针和 sp 指针有相同的指针。再次强调，weak\_ptr 类型指针不会导致堆内存空间的引用计数增加或减少。

weak\_ptr模板类提供的成员方法:

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/56.png)

再次强调，weak\_ptr<T> 模板类没有重载 * 和 -> 运算符，因此 weak\_ptr 类型指针只能访问某一 shared\_ptr 指针指向的堆内存空间，无法对其进行修改。

### <p id="shared_ptr简单实现">shared_ptr简单实现</p>

shared\_ptr有一个非常重要的问题需要我们去思考，我们如何去判断是否有多个智能指针指向同一个对象呢，也即何时引用计数会增加，何时引用计数会减少。

在此之前，我们考虑一个普通指针所具有的问题： **悬垂指针问题**

当我们有两个指针，共享同一个对象：

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/57.png)

当其中一个指针删除了其所指向的对象，那么另一个指针将会变成悬垂指针（这也是不重载拷贝构造函数以及赋值函数可能遇到的问题）。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/58.png)

为了解决此问题，引入了智能指针，目前的智能指针的实现策略有两种：引用计数类与句柄类（《C++Primer》15.8.1）。这里介绍引用计数类的实现方法。

**引用计数：**
定义智能指针的通用技术是采用一个引用计数（use count）。智能指针类将一个计数器与类指向的对象相关联。引用计数跟踪该类有多少个对象共享同一个指针。引用计数为0时，删除对象。

**引用计数类：**
定义一个具体类（U_Ptr）来封装引用计数和指针。在创建智能指针类之前，这个类的所有成员皆为私有类型，因为它不被普通用户所使用。为了只为智能指针使用，还需要把智能指针类声明为该类的友元。类中包含含两个数据成员：计数count与之前HasPtr类中的指针（ int *ptr;）。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/59.png)

当我们复制这个对象时

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/60.png)

这样实现引用计数类：
<pre>
class HasPtr;
class U_Ptr {
    private:
    friend class HasPtr;

    U_Ptr(int *p);
    ~U_Ptr();
    
    int *m_ip;
    int m_useCount;
};

U_Ptr::U_Ptr(int *p)
    :m_ip(p)
    ,m_useCount(1)
{

}

U_Ptr::~U_Ptr()
{
    cout<< "U_Ptr destruct"<< endl;
    if（NULL != m_ip） {
    	delete m_ip;
    	m_ip = NULL;
    }
}
</pre>

以及智能指针类：

<pre>
class HasPtr {

    public:
        HasPtr(int *p = 0, int i = 0);
        HasPtr(const HasPtr &ptr);
        HasPtr& operator=(const HasPtr &rhs);
        ~HasPtr();

        int *get_ptr() const;
        void set_ptr(int *p);

        int get_int() const;
        void set_int(int i);

        int get_ptr_val() const;
        void set_ptr_val(int val);

    private:
        int m_val;
        U_Ptr *m_uptr;

};
HasPtr::HasPtr(int *p, int i)
    :m_uptr(new U_Ptr(p))
    ,m_val(i)
{
    cout<<"HasPtr  constructor"<<endl;
}

HasPtr::HasPtr(const HasPtr &ptr)
    :m_uptr(ptr.m_uptr)
    ,m_val(ptr.m_val)
{
    cout<<"HasPtr copy constructor m_uptr->m_useCount = "<<m_uptr->m_useCount<<endl;
    ++m_uptr->m_useCount;
}

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
    cout<< "HasPtr assignment rhs.m_uptr->m_useCount = "<< rhs.m_uptr->m_useCount<< endl;
    cout<< "HasPtr assignment m_uptr->m_useCount = "<< m_uptr->m_useCount<< endl;
    ++rhs.m_uptr->m_useCount;
    if (--m_uptr->m_useCount == 0) {
        delete m_uptr;
    }
    m_uptr = rhs.m_uptr;
    m_val = rhs.m_val;
    return *this;
}

int *HasPtr::get_ptr() const {
    return m_uptr->m_ip;
}

void HasPtr::set_ptr(int *p) {
    m_uptr->m_ip = p;
}

int HasPtr::get_int() const {
    return m_val;
}

void HasPtr::set_int(int i) {
    m_val = i;
}

int HasPtr::get_ptr_val() const {
    return *m_uptr->m_ip;
}

void HasPtr::set_ptr_val(int val) {
    *m_uptr->m_ip = val;
}

HasPtr::~HasPtr() {
    cout<< "HasPtr destruct m_uptr->m_useCount = "<< m_uptr->m_useCount<< endl;
    if (--m_uptr->m_useCount == 0) {
        delete m_uptr;
        m_uptr = NULL;
    }
}
</pre>
可以使用以下程序进行测试：
<pre>
int main() {
int *ip = new int(12);
    HasPtr ptr(ip, 20);            //执行构造函数
    HasPtr ptr1(ptr);              //执行复制构造函数
    HasPtr ptr2(ptr);             //执行复制构造函数
    // 下面使用花括号是为了控制HasPtr对象生命周期
    {
        HasPtr ptr3 = NULL;      //执行构造函数
        ptr3 = ptr;              //执行赋值函数
        // HasPtr ptr3 = ptr；    //注意，这里调用的是复制构造函数，因为有新对象创建
    }
	return 0;
}
</pre>
运行结果：
<pre>
U_Ptr constructor
HasPtr constructor
HasPtr copy constructor m_uptr->m_useCount = 1
HasPtr copy constructor m_uptr->m_useCount = 2
U_Ptr constructor
HasPtr constructor
HasPtr assignment rhs.m_uptr->m_useCount = 3
HasPtr assignment m_uptr->m_useCount = 1
U_Ptr destruct //左操作数指向的对象被回收
HasPtr destruct m_uptr->m_useCount = 4
HasPtr destruct m_uptr->m_useCount = 3
HasPtr destruct m_uptr->m_useCount = 2
HasPtr destruct m_uptr->m_useCount = 1
U_Ptr destruct //删除指针
</pre>

**这里的实现方法并不是最全的，但是原理基本类似，其实想强调的是引用计数何时改变的事情：**

关联的计数器(引用计数)递增一的情况：可以和调用拷贝构造函数类比。

1. 用一个shared\_ptr初始化另一个shared\_ptr；
2. shared\_ptr作为参数传递给一个函数 ；
3. shared\_ptr作为函数的返回值。

关联的计数器(引用计数)递减一的情况：

1. 给shared\_ptr赋值一个新值 (operator= 或 reset() 赋值)；
2. shared\_ptr被销毁(例如局部的shared\_ptr离开其作用域)。同时如果一个shared\_ptr的计数器变为0，就会释放自己所管理的对象。


### <p id="shared_ptr循环引用问题">shared_ptr循环引用问题</p>

shared\_ptr的引用计数会带来循环引用的问题，导致堆内存无法正常回收，造成内存泄漏。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/53.png)

<pre>
class B;
class A {
	public://为了省去一些步骤，数据成员全部声明为public
		shared_ptr< B> pb;
		void doSomething(){}
		~A(){
			cout<< "kill A\n";
		}
};
class B {
	public:
		shared_ptr< A> pa;
		void doSomething(){}
		~B(){
			cout<< "kill B\n";
		}
};

int main() {
	shared_ptr< A> sa(new A());
	shared_ptr< B> sb(new B());
	if(sa && sb ){
		sa->pb = sb;
		sb->pa = sa;
	} 
	cout<< "sa use count: "<< sa.use_count()<< endl;
	return 0;
}
</pre>
上面运行结果为2.此时sa，sb没有释放，即A内部有指向B，B内部有指向A，对于A，B必定是在A析构后B才析构，对于B，A必定是B析构后才析构A。
要解决该问题，有三种解决方法：

- 当只剩下最后一个引用的时候需要手动打破循环引用释放对象。
- 当A的生存期超过B的生存期的时候，B改为使用一个普通的指针指向A。
- 使用弱引用的智能指针。

下面将使用weak\_ptr来配合这解决循环引用问题：
<pre>
class B;
class A {
	public://为了省去一些步骤，数据成员全部声明为public
		weak_ptr< B> pb;
		void doSomething(){
			shared_ptr< B> pp = pb.lock();
			if(pp) {//通过lock（）方法来判断其所管理资源是否被释放
				cout<< "sb use count: "<< pp.use_count()<< endl;
			}
		}
		~A(){
			cout<< "kill A\n";
		}
};
class B {
	public:
		shared_ptr< A> pa;
		void doSomething(){}
		~B(){
			cout<< "kill B\n";
		}
};

int main() {
	shared_ptr< A> sa(new A());
	shared_ptr< B> sb(new B());
	if(sa && sb ){
		sa->pb = sb;
		sb->pa = sa;
	} 
	sa->doSomething();
	cout<< "sb use count: "<< sb.use_count()<< endl;
	return 0;
}
</pre>
此时运行结果为：
<pre>
sb use count: 2
sb use count: 1
kill B
kill A 
</pre>

首先我们要知道lock()方法返回值，如果weak\_ptr没有失效，那么返回一个和weak\_ptr同指向的shared\_ptr，也即doSomething()中所输出的值，我们可以看到2个指针指向同一个对象sb。在doSomething()的作用域过了之后，sb引用计数变为了1，两个对象可以正常释放。

## <p id="C++基础补充">C++基础补充</p>
### <p id="C++与C的区别">C++与C的区别</p>
- C++是面向对象的语言，C是面向过程的语言。
- C++中new和delete是对内存分配的运算符，取代了C中malloc和free。
- C++有引用的概念，C中没有。
- C++有类的概念，C中没有。
- C++有函数重载，C中不能。
- C变量只能在函数的开头处声明和定义，C++随时定义随时使用。
- C++相比C，增加了许多类型安全的功能，比如强制类型转换。
- C++支持范式编程，比如模板类，函数模板等。

### <p id="C++与java的区别">C++与java的区别</p>
- Java的应用在高层，C++在中间件和底层。
- Java语言简洁；取消了指针带来更高的代码质量；完全面向对象，独特的运行机制是其具有天然的可移植性。
- Java在web应用上具有C++无可比拟的优势 。
- 垃圾回收机制的区别。C++ 用析构函数回收垃圾,Java自动回收,写C和C++程序时一定要注意内存的申请和释放。
- Java用接口(Interface)技术取代C++程序中的多继承性。
### <p id="C++与Python的区别">C++与Python的区别</p>
- C++为编译型语言；python为解释型的脚本语言。
- C++效率高，编程难；python效率低，编程简单。
- python有很多库函数可以调用。使其可以应用到各种场景，而C++主要是应用于底层框架，音视频流。
### <p id="面向对象">面向对象的三大特征</p>
面向对象是一种基于对象的、基于类的的软件开发思想。面向对象具有继承、封装、多态的特性。

**封装**就是隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。

封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。

**继承**是面向对象的基本特征之一，继承机制允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

**多态**同一个行为具有多个不同表现形式或形态的能力。是指一个类实例（对象）的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。
### <p id="C++大括号的作用">C++大括号的作用</p>
除了在函数中使用大括号，使用大括号可以指定变量的生命周期，如下：
<pre>
{
	int d = 4;
	cout<< d;
}
cout<< d;
</pre>
第一个输出可以输出d，第二个会报错，显示d没有被定义。

### <p id="new/delete和malloc/free区别">C++ new/delete和malloc/free区别</p>

- new/delete是C++的关键字，而malloc/free是库函数，new/delete可以进行重载，而malloc/free不行。
- new时不需要指定空间的大小，但是需要指定分配对象类型，返回的也是该类型的指针；而malloc时需要指定空间大小，无需指定数据类型，返回的是void*泛型指针。
- new失败时直接抛出异常，而malloc则是返回NULL。
- new时会先调用malloc，然后调用所分配对象的构造函数进行构造。
- new操作符是从自由存储区上为对象动态分配内存空间，malloc函数是从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行的内存申请的，该内存成为**自由存储区**。而自由存储区的位置取决于operator new的实现细节，自由存储区不仅可以是堆（C++编译器默认使用堆来实现自由存储，也即调用malloc），也可以是静态存储区（通过重载操作符，改用其他内存来实现自由存储），取决于operator new在哪里为对象分配内存。
- 使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针，如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。new没有这样直观的配套设施来扩充内存。
- malloc只负责开辟内存，没有初始化功能，需要用户自己初始化，new不但开辟内存，还可以进行初始化。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/61.png)

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/62.png)

**malloc实现原理：**

malloc函数实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，沿着连接表寻找一个大到足以满足用户请求所需要的内存块。然后将该内存块一分为二，接下来将分配给用户的那块内存存储区域传给用户，然后将剩下的块返回到连接表上。调用free函数时，将用户释放的内存块连接到空闲链表上，最后空闲链表会被切成很多的小内存片段。如果此时用户申请一个大的内存片段，那么空闲链表上可能没有满足用户的片段。malloc请求延时，并开始在空闲链表上检查各内存片段，对他们进行内存整理，将相邻的小空间块合并成较大的内存块。

搜索空间快最常见算法：首次适配，下一次适配，最佳适配。

**new/delete实现原理：**

对于简单的数据类型（包含基本数据类型和不需要构造函数的类型），new 操作直接会调用operator new来分配内存（默认使用malloc），new分配失败时不像malloc返回NULL，而是直接抛出异常（bad\_alloc），可以使用new\_handler处理。

对于复杂的数据类型，先调用operator new，然后在分配的内存上调用构造函数初始化。

对于delete同理，对于复杂的数据类型，先调用析构函数，再调用operator delete。
注意在new[]一个复杂数据类型时，先调用operator new[]分配内存，然后在p的前四个字节写入数组大小，最后调用n次构造函数。如此做的原因是，释放内存时会调用每个对象的析构函数，但是编辑器并不知道p实际所指对象的大小。如果没有存储数组大小，编译器如何知道该把p所指的内存分为几次来调用析构函数呢？
### <p id="C++空类有什么默认函数">C++ 空类有什么默认函数</p>
- 默认构造函数和拷贝构造函数。
- 析构函数。
- 赋值函数（赋值运算符=）。
- 取址运算符&以及const &重载。
- C++11 中加入默认控制函数（=default， =delete）。
### <p id="C++内存泄露">C++ 内存泄露</p>
**C++内存泄露的几种情况：**

- **在类的构造函数和析构函数中没有匹配的调用new和delete函数。**两种情况会产生这种内存泄露。1）在堆内创建了对象占用了内存，但是没有显式的释放掉。2）在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确释放内存。
-** 没有正确地清除嵌套的对象指针。**
- **在释放对象数组时，在delete中没有使用方括号。**方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并且调用对象的析构函数，如果没有方括号，那么指针就被默认为指向一个对象，对象数组中其他对象的析构函数也不会被调用，造成内存泄露。如果在方括号中放了一个比对象数组还大的数字，那么编译器会调用无效对象的析构函数，造成堆的崩溃。如果方括号中的数字值比对象数组大小还小的话，同样会造成内存泄露。（释放单个对象，单个基本数据类型的变量或者基本数据类型的数组不需要大小参数，释放定义了析构函数的对象数组才需要大小参数。）
- **指向对象的指针数组不等同于对象数组。**1）对象数组是指：数组中存放的是对象，只需要使用delete []p，即可调用对象数组中的每个对象的析构函数来释放空间。2）指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅需要释放每个对象的空间，还要释放每个指针的空间，delete[]p只是释放了每个指针，但是没有释放对象的空间，应该通过一个循环，先释放每一个对象，再释放指针。
- **缺少拷贝构造函数。**两次释放相同的内存是一种错误的做法，同时可能造成堆的崩溃。按值传递会调用（拷贝）构造函数，引用传递不会。在C++中，如果没有定义拷贝构造函数，那么编译器会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量，这种隐式的指针复制的结果就是两个对象拥有指向同一个动态分配空间的指针。当释放掉第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间，而释放第二个对象的时候，它的析构函数就会释放相同的内存，这样是错误的。所以，如果一个类里面有指针成员变量，要么必须显式的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符。
- **缺少重载赋值运算符。**该问题与上述问题类似，也是逐个成员拷贝的方式复制对象，如果这个类的大小是可变的，那么结果就是造成内存泄露。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/63.png)

- **没有将基类的析构函数定义为虚函数。**当基类指针指向子类对象时，如果基类的析构函数不是虚函数，那么在释放时，子类的析构函数不会被调用，导致子类的资源无法被正确释放 。
- **构造函数调用new开辟内存后，抛出异常。**此时会导致对象未构建成功，不会调用析构函数，导致new的堆内存无法释放。
- **僵尸进程。**父进程不处理僵尸进程导致进程内核栈泄露。

### <p id="C++野指针">C++ 野指针</p>

**野指针：**野指针是指指向被释放的或者访问受限内存的指针。造成野指针的原因有：

1. 指针变量没有初始化。（可以初始化为NULL)
1. 指针被free/delete掉之后，没有设置为NULL，free和delete只是把指针所指向的内存释放掉，并没有把指针本身干掉，此时指针应该被设置为NULL。
1. 指针操作超越了变量的作用范围，比如返回指向栈内存的指针。

### <p id="C++内存对齐">C++ 内存对齐</p>
尽管内存是以字节为单位，但是大部分处理器并不是按字节块存取的，一般会以双字节，四字节，八字节等为单位来存取内存。如果没有内存对齐机制，数据可以任意存放，容易造成cpu资源浪费（例如cpu一次读取4字节，新数据起始地址在第二字节处，这样cpu会先读第一个4字节数据，并将后两字节保存，然后读取第二个4字节数据，将前两个字节保存，cpu读取了两次，效率相对较低）。

- **数据成员对齐规则：**结构体（struct）或者联合（union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员的大小或者成员的子成员的大小（只要该成员有子成员，比如数组或者结构体等）的整数倍开始。
- **结构体作为成员：**在一个结构体里有其他结构体，那么结构体要从其内部“最宽基本类型成员"的整数倍地址开始存储。
- **收尾工作：**结构体的总大小，必须是其内部最大成员“最宽基本类型成员”的整数倍。（基本类型不包括struct/class/union）。

<pre>
struct A{
	//(a,b,0) c (d,0) 一共12字节 
	char a;//0
	char b;//1
	int c; //4
	char d;//8 
}; 
struct B{
	//(a,0) b (c,0)一共24字节 
	char a;//0
	double b;//8
	int c; //16
	
}; 
struct C{
	//(a,0) (b.a), (b.b), (b.c), (c,0)一共40字节 
	char a;//0
	struct B b;//A 的最宽基本类型成员大小为8，从8开始 
	int c; //32
	
}; 
struct D{
	//一共12字节 
	int a;//0
	int b;//4
	int c;//8
};
struct E{
	//(a,0,d.a) (d.b,d.c), c 一共24字节  
	char a;//0
	struct D b;//D 的最宽基本类型成员大小为 4，从4的整数倍开始 
	double c;//16
};
struct Books {
	//空类占一个字节 
}; 
int main() {

	A a;
	B b;
	C c;
	D d;
	E e;
	Books f;
	cout<< "struct A: "<< sizeof(a) << endl;
	cout<< "struct B: "<< sizeof(b) << endl;
	cout<< "struct C: "<< sizeof(c) << endl;
	cout<< "struct D: "<< sizeof(d) << endl;
	cout<< "struct E: "<< sizeof(e) << endl;
	cout<< "struct F: "<< sizeof(f) << endl;
	return 0;
}
</pre>
运行结果：
<pre>
struct A: 12
struct B: 24
struct C: 40
struct D: 12
struct E: 24
struct F: 1
</pre>
### <p id="C++volatile关键字">C++ volatile关键字</p>
C/C++中的volatile关键字和const对应，用来修饰变量。是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，如操作系统，硬件或者其他线程。**是线程间通信的一种方式。**cpu会优先访问数据在寄存器中的值，但是此时内存内该数据的值可能发生了改变，因此要使用volatile关键字。

**主要使用地方：**

1. 中断服务程序中修改的供其他程序检测的变量需要加volatile。
1. 多任务环境下各任务间共享的标志应该加volatile。
1. 存储器映射的硬件寄存器通常也要加volatile声明，因为每次对它的读写可能都不同意义。

可以将一个非volatile int赋给volatile int，但是不能把非volatile对象赋给volatile对象。
### <p id="C++struct">C++ struct</p>
C++数组允许定义和存储相同类型数据项的变量，但是**结构体**是C++中另一种用户自定义的可用的数据类型，它允许用户存储不同类型的数据项。
<pre>
struct Books {
	char title[50];
	char author[50];
	char subject[100];
	int book_id;
} book;
</pre>

type_name（Books）是结构体类型的名称，在结构定义的末尾，最后一个分号之前，可以指定一个或者多个结构变量（可选，可以不指定），上图声明了一个结构体类型Books，变量book。

**C++struct与class区别**

C++中结构体的引入主要是为了保证和C语言的兼容性。

- 使用class时，类中的成员默认是private属性的，而是用struct时，结构体中的成员默认都是public属性的。
- class继承默认是private继承，而struct继承默认是public继承。
- class可以使用模板，struct不能。
- class可以包含成员函数，struct一般不包含（C语言不可以，C++可以）。
- struct通常作为数据结构的实现体，class作为对象的实现体。

**typedef关键字**

typedef可以为你创造的类型取一个别名，这样可以直接用结构变量（此时变量变成了结构体名称）名称来定义变量。
<pre>
typedef struct Books{
	string title = "this is title";
	char author[50];
}book, book2;
</pre>
如上图可以使用book和book2来定义变量。

typedef关键字还可以定义非结构体类型：
<pre>
typedef long int* pint32;

pint32 x, y, z;
</pre>
C++中空结构体（空类）大小为1，C中空结构体大小为0.因为C++中即使是空结构体，也可以被实例化。所以需要一个字节去保存地址。
### <p id="C++string">C++ string</p>

<pre>
string s1;
string s2 = "c plus plus";
string s3 = s2;
string s4(5, 's');
</pre>

- 变量 s1 只是定义但没有初始化，编译器会将默认值赋给 s1，默认值是""，也即空字符串。
- 变量 s2 在定义的同时被初始化为"c plus plus"。与C风格的字符串不同，string 的结尾没有结束标志'\0'。
- 变量 s3 在定义的时候直接用 s2 进行初始化，因此 s3 的内容也是"c plus plus"。
- 变量 s4 被初始化为由 5 个's'字符组成的字符串，也就是"sssss"。

从上面的代码可以看出，string 变量可以直接通过赋值操作符=进行赋值。string 变量也可以用C风格的字符串进行赋值，例如，s2 是用一个字符串常量进行初始化的，而 s3 则是通过 s2 变量进行初始化的。

在C语言中，有两种方式表示字符串：

- 一种是用字符数组来容纳字符串，例如char str[10] = "abc"，这样的字符串是可读写的；
- 一种是使用字符串常量，例如char *str = "abc"，这样的字符串只能读，不能写。

两种形式总是以\0作为结束标志。

C++ string 与它们在C语言中的前身截然不同。首先，也是最重要的不同点，C++ string 隐藏了它所包含的字符序列的物理表示。程序设计人员不必关心数组的维数或\0方面的问题。

string 在内部封装了与内存和容量有关的信息。具体地说，C++ string 对象知道自己在内存中的开始位置、包含的字符序列以及字符序列长度；当内存空间不足时，string 还会自动调整，让内存空间增长到足以容纳下所有字符序列的大小。

C++ string 的这种做法，极大地减少了C语言编程中三种最常见且最具破坏性的错误：

- 数组越界；
- 通过未被初始化或者被赋以错误值的指针来访问数组元紊；
- 释放了数组所占内存，但是仍然保留了“悬空”指针。

C++ 标准没有定义 string 类的内存布局，各个编译器厂商可以提供不同的实现，但必须保证 string 的行为一致。采用这种做法是为了获得足够的灵活性。

特別是，C++ 标准没有定义在哪种确切的情况下应该为 string 对象分配内存空间来存储字符序列。string 内存分配规则明确规定：允许但不要求以引用计数（reference counting）的方式实现。但无论是否采用引用计数，其语义都必须一致。

**字符串变量**

- 字符串是以**空字符（'\0')结束的字符数组。**
- 空字符'\0'自动添加到字符串的内部表示中。
- 在声明字符串变量时，应该为这个空结束符预留一个额外元素的空间。如char strHello[11] = {"helloworld"};

**字符串常量**

- 字符串常量是一对双引号括起来的字符序列。
- 字符串中每个字符作为一个数组元素存储。
- 例如字符串“helloworld”。

### <p id="C++内联函数">C++ 内联函数</p>


**函数调用是有时间和空间开销的。**程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。
为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为**内联函数（Inline Function）**，又称**内嵌函数**或者**内置函数**。

指定内联函数的方法很简单，只需要在函数定义处增加 inline 关键字。请看下面的例子：

<pre>
inline void swap(int *a, int *b){
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
int main(){
    int m, n;
    cin>>m>>n;
    cout<< m<< ", "<< n<< endl;
    swap(&m, &n);
    cout<< m<< ", "<< n<< endl;
    return 0;
}
</pre>
<font color=red>注意，要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。</font>

当编译器遇到函数调用swap(&m, &n)时，会用 swap() 函数的代码替换swap(&m, &n)，同时用实参代替形参。这样，swap(&m, &n)就被置换成：
<pre>
int temp;
temp = *(&m);
*(&m) = *(&n);
*(&n) = temp;
</pre>
使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。

**内联函数的一个作用就是可以替代宏。**

宏是可以带参数的，它在形式上和函数非常相似。不过不像函数，宏仅仅是字符串替换，不是按值传递，所以在编写宏时要特别注意，一不小心可能就会踩坑。
<pre>
#define SQ(y) y*y
int main(){
    int n, sq;
    cin>>n;
    sq = SQ(n);
    cout<< sq<< endl;
    return 0;
}
</pre>
运行结果
<pre>
输入9
输出81
</pre>
但如果我们使用以下调用：
<pre>
#define SQ(y) y*y
int main(){
    int n, sq;
    cin>>n;
    sq = SQ(n+1);
    cout<< sq<< endl;
    return 0;
}
</pre>
运行结果
<pre>
输入9
输出19
</pre>
我们期望的结果是 100，但这里却是 19，两者大相径庭。这是因为，宏展开仅仅是字符串的替换，不会进行任何计算或传值，上面的sq = SQ(n+1);在宏展开后会变为sq = n+1*n+1;，这显然是没有道理的。

如果我们将宏替换为内联函数，情况就没有那么复杂了，程序员就会游刃有余，请看下面的代码：
<pre>
inline int SQ(int y){ return y*y; }
int main(){
    int n, sq;
    cin>>n;
    //SQ(n)
    sq = SQ(n);
    cout<< sq<< endl;
    //SQ(n+1)
    sq = SQ(n+1);
    cout<< sq<< endl;
    //200 / SQ(n+1)
    sq = 200 / SQ(n+1);
    cout<< sq<< endl;
    return 0;
}
</pre>
运行结果
<pre>
输入9
输出81
输出100
输出2
</pre>
**和宏一样，内联函数可以定义在头文件中（不用加 static 关键字），并且头文件被多次#include后也不会引发重复定义错误。**这一点和非内联函数不同，非内联函数是禁止定义在头文件中的，它所在的头文件被多次#include后会引发重复定义错误。

内联函数在编译时会将函数调用处用函数体替换，编译完成后函数就不存在了，所以在链接时不会引发重复定义错误。这一点和宏很像，宏在预处理时被展开，编译时就不存在了。从这个角度讲，内联函数更像是编译期间的宏。

在类体中和类体外定义成员函数是有区别的：在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。当然，在类体内部定义的函数也可以加 inline 关键字，但这是多余的，因为类体内部定义的函数默认就是内联函数。

**再次强调，虽然 C++ 支持将内联函数定义在类的外部，但我强烈建议将函数定义在类的内部，这样它会自动成为内联函数，何必费力不讨好地将它定义在类的外部呢，这样并没有任何优势。**

### <p id="C++RTTI">C++ RTTI</p>
RTTI(Run Time Type Identification)即运行时类型识别机制，程序能够使用基类的指针或者引用来检查这些指针或者引用所指对象的实际派生类型。

为了满足C++对多态的要求，C++中的指针或者引用的本身的类型，可能与他实际代表（指向或者引用）的类型并不一致。有时我们需要将一个多态指针转化为其实际指向的对象类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。

RTTI提供了两个非常有用的操作符：typeid和dynamic_cast。

typeid操作符，返回指针和引用所指的实际类型。

dynamic_cast操作符，将基类类型的指针或者引用安全地转移为其派生类类型的指针或者引用。

C++中，对于多态对象，无法在程序编译阶段确定对象的类型，当类中含有虚函数时，其基类的指针就可以指向任何派生类的对象，这时就会有可能出现不知道基类指针到底指向那个对象的情况，类型的确定要在运行时通过运行时类型识别机制实现。为了获取一个对象的类型可以使用typeid函数，该函数返回一个对type_info类对象的引用（头文件<typeinfo>）。

type\_info类的拷贝构造函数和赋值运算符都是私有的，所以不允许用户自己创建type\_info类，type\_info类重载了==和！=用于比较两个对象类型是否相等。

dynamic_cast主要用于多态的时候，它允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构中安全地转移类型，把基类指针（引用）转换为派生类指针（引用）。

当类中存在虚函数时，编译器会在类的成员变量中添加一个指向虚函数表的vptr指针，每一个class所关联的type\_info object也经由virtual table被指出来，通常这个type\_info object放在表格的第一个slot。当我们运行dynamic\_cast时，编译器就会帮我们进行语法检查。如果指针的静态类型和目标类型相同，那就什么也不干，否则，首先对指针进行调整，使得它指向vrtable，并将其和调整之后的指针，偏移量，静态类型以及目标类型传递给内部函数，其中最后一个参数知名转换的是指针还是应用。如果转换失败，前者返回NULL，后者抛出bad\_cast异常。
### <p id="C++void*">C++ void*</p>
void\*指针不指向任何数据类型，它属于一个未确定种类的过渡型数据，因此如果要访问实际存在的数据，必须将void\*指针强制转换为指定一个确定的数据类型的数据，如int\*，string\*等。void\*指针只支持几种有限的操作：与另一个指针进行比较，向函数传递void\*指针或者从函数返回void\*指针，给另一个void\*指针赋值。不允许使用void\*指针操作它所指向的对象，例如，不允许对void\*指针进行解引用。不允许对void\*指针进行算数操作。
void\*就像一张白纸，任何类型指针都可以直接赋给void\*类型的指针，对于32位机器，指针变量占用4字节，64位机占用8字节。
### <p id="memecpy和strcpy">memecpy和strcpy</p>

strcpy和memcpy都是标准C库函数。

**strcpy**

strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符。

已知strcpy函数的原型是：char* strcpy(char* dest, const char* src);

函数说明：strcpy()会将参数src字符串拷贝至参数dest所指的地址。返回dest字符串的起始地址。

<pre>
char * strcpy(char * dest, const char * src) // 实现src到dest的复制
{
　　if ((src == NULL) || (dest == NULL)) //判断参数src和dest的有效性
　　{
　　　　　　return NULL;
　　}
　　char *strdest = dest;        //保存目标字符串的首地址
　　while ((*strDest++ = *strSrc++)!='\0'); //把src字符串的内容复制到dest下
　　return strdest;
}
</pre>

**memcpy**

memcpy提供了一般内存的复制。即memcpy对于需要复制的内容没有限制，因此用途更广。

void *memcpy( void *dest, const void *src, size_t count );

函数说明：memcpy()用来拷贝src所指的内存前count个字节到dest所指内存地址上。  memcpy会赋值完整的count个字节，不会因为遇到字符串结束'\0'而结束。
<pre>
void *memcpy(void *memTo, const void *memFrom, size_t size)
{
　　if((memTo == NULL) || (memFrom == NULL)) //memTo和memFrom必须有效
         return NULL;
　　char *tempFrom = (char *)memFrom;             //保存memFrom首地址
　　char *tempTo = (char *)memTo;                  //保存memTo首地址      
　　while(size -- > 0)                //循环size次，复制memFrom的值到memTo中
       　　*tempTo++ = *tempFrom++ ;  
　　return memTo;
}
</pre>

**strcpy和memcpy主要有以下3方面的区别。**

1. 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。
1. 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。
1. 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy

### <p id="C++设计模式">C++ 设计模式</p>

软件设计模式有许多种，这里只介绍两种，单例模式和观察者模式。

**单例模式**

指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。

在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。

单例模式有 3 个特点：

- 单例类只有一个实例对象；
- 该单例对象必须由单例类自行创建；
- 单例类对外提供一个访问该单例的全局访问点。

**单例模式的优点和缺点**

单例模式的优点：

- 单例模式可以保证内存里只有一个实例，减少了内存的开销。
- 可以避免对资源的多重占用。
- 单例模式设置全局访问点，可以优化和共享资源的访问。

单例模式的缺点：

- 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。
- 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。
- 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。

**单例模式的创建方式**

主要分为**懒汉式**和**饿汉式**。实现思路是：

1. 类拥有一个私有构造函数，确保用户无法从new直接实例化。
2. 包含一个静态私有成员变量instance与静态公有方法getInstance()。

单例模式的主要角色如下。

- 单例类：包含一个实例且能自行创建这个实例的类。
- 访问类：使用单例的类。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/64.png)

**懒汉式单例模式**

该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。

<pre>
public class LazySingleton {
    private static volatile LazySingleton instance = null;    //保证 instance 在所有线程中同步
    private LazySingleton() {
    }    //private 避免类在外部被实例化
    public static synchronized LazySingleton getInstance() {
        //getInstance 方法前加同步
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
</pre>
如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。

**饿汉式单例模式**
该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。
<pre>
public class HungrySingleton {
    private static final HungrySingleton instance = new HungrySingleton();
    private HungrySingleton() {
    }
    public static HungrySingleton getInstance() {
        return instance;
    }
}
</pre>
饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。

**观察者模式**

观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。在观察者模式中，观察者需要直接订阅目标事件，在目标发出内容改变的事件后，直接接受事件并作出响应。

观察者模式是一种对象行为型模式，其主要优点如下：

- 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。
- 目标与观察者之间建立了一套触发机制。

它的主要缺点如下：

- 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。
- 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。

**观察者模式的实现**

实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用，否则将使两者之间紧密耦合起来，这违反了面向对象的设计原则。实现思路是将Observable以及Observer抽象开，分清楚抽象和实体。

**模式的结构**

观察者模式的主要角色如下：

- 抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。
- 具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。
- 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。
- 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。

![](https://raw.githubusercontent.com/ZHANGHanYuhhh/C-/main/C%2B%2BReview/65.png)

消息接收方:Observer.h

<pre>
# ifndef OBSEVER_H_1
# define OBSEVER_H_1
class Observer
{
public:
	Observer() { ; }
	virtual ~Observer() { ; }

	// 当被观察对象发生变化时，通知被观察者调用这个方法
	virtual void Update(void* pArg) = 0;
};
# endif
</pre>

消息发布方：Observerable

<pre>
class Observer;

#include < string>
#include < list>
using namespace std;
class Observerable
{
public:
	Observerable();
	virtual ~Observerable();

	// 注册观察者
	void Attach(Observer* pOb);
	// 反注册观察者
	void Detach(Observer* pOb);

	int GetObseverCount() const
	{
		return _Obs.size();
	}

	void DetachAll()
	{
		_Obs.clear();
	}

	virtual void GetSomeNews(string str)
	{
		SetChange(str);
	}
protected:
	void  SetChange(string news);   // 有变化，需要通知

private:
	void Notify(void* pArg);

private:
	bool _bChange;
	list<Observer*> _Obs;
};
Observerable::Observerable():_bChange(false)
{

}


Observerable::~Observerable()
{
}


// 注册观察者
void Observerable::Attach(Observer* pOb)
{
	if (pOb == NULL)
	{
		return;
	}

	// 看看当前列表中是否有这个观察者
	auto it = _Obs.begin();
	for (; it != _Obs.end(); it++)
	{
		if (*it == pOb)
		{
			return;
		}
	}

	_Obs.push_back(pOb);
}

// 反注册观察者
void Observerable::Detach(Observer* pOb)
{
	if ((pOb == NULL) || (_Obs.empty() == true))
	{
		return;
	}

	_Obs.remove(pOb);
}

void Observerable::SetChange(string news)
{
	_bChange = true;

	Notify( ( (void*)news.c_str() ));
}


void Observerable::Notify(void* pArg)
{
	if (_bChange == false)
	{
		return;
	}

	// 看看当前列表中是否有这个观察者
	auto it = _Obs.begin();
	for (; it != _Obs.end(); it++)
	{
		(*it)->Update(pArg);
	}

	_bChange = false;
}
</pre>

main函数
<pre>
class News : public Observerable
{
public:
	virtual void GetSomeNews(string str)
	{
		SetChange("News: " + str);
	}
};

class User1:public Observer
{
public:
	virtual void Update(void* pArg)
	{
		cout << "User1 Got News: " ;reinterpret_cast<char*>(pArg) << endl;
	}
};
class User2 :public Observer
{
public:
	virtual void Update(void* pArg)
	{
		cout << "User2 Got News: " << reinterpret_cast<char*>(pArg) << endl;
	}
};

int main()	
{
	User1 u1;
	User2 u2;

	News n1;
	n1.GetSomeNews("T0");
	cout << n1.GetObseverCount() << endl;  // 0

	n1.Attach(&u1);
	n1.Attach(&u2);
	n1.GetSomeNews("T1");
	cout << n1.GetObseverCount() << endl;  // 2

	n1.Detach(&u2);
	n1.GetSomeNews("T2");
	cout << n1.GetObseverCount() << endl;  // 1

	n1.DetachAll();
	n1.GetSomeNews("T3");
	cout << n1.GetObseverCount() << endl;  // 0

    return 0;
}

</pre>
